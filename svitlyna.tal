|00 @System [ 
	&vector $2 &expansion $2 &wst $1 &rst $1 
	&metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1 
]
|10 @Console [ 
	&vector $2 &read $1 &pad $4 
	&type $1 &write $1 &error $1
]
|20 @Screen [ 
	&vector $2 &width $2 &height $2 &auto $1 &pad 
	$1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1600
]
|a0 @File [ 
	&vector $2 &success $2 &stat $2 &delete $1 
	&append $1 &name $2 &length $2 &read $2 &write $2
]

|0000 
@x $2 @y $2
@img-w $2 @img-h $2

( see bottom of file for reasoning )
%Mmax-w-smol { #0200 }
%Mmax-w-big { #1000 }

( max width is 4096, max height is also 4096, thus maximum size is 
 24 bits, this is used in the cumulutive average formula for colors )
%Mmax-h-big { #0fff }

%Mmax-name-length { #00ff }

@color0 [ &r $1 &g $1 &b $1 ]
@color1 [ &r $1 &g $1 &b $1 ]
@color2 [ &r $1 &g $1 &b $1 ]
@color3 [ &r $1 &g $1 &b $1 ]

(       Farbfeld                 )
(	ff-magic-2 ff-pixel      )
@buf [
	&ff-w-high &ff-r     $2
	&ff-w-low  &ff-g     $2     
	&ff-h-high &ff-b     $2
	&ff-h-low  &ff-a     $10
]
@buf-size-expect $1 @buf-on-read $2
%Mbuf-next { .buf-size-expect STZ .buf-on-read STZ2 }

%Mcout { .Console/write DEO }
%Mendl { #0a Mcout }

%Mprint-short { SWP print-byte print-byte }
%Mdebug-byte { Mcout DUP print-byte }
%Mdebug-short { Mcout OVR print-byte DUP print-byte }
%Mdebug32 { Mcout OVR2 Mprint-short DUP2 Mprint-short }
%Mdebug-rgb { 
	Mcout LIT "# Mcout 
	ROT DUP print-byte 
	ROT DUP print-byte
	ROT DUP print-byte
}

%Mprint-bgr { 
	LIT "# Mcout 
	print-byte print-byte print-byte Mendl 
}
%Mprint-rgb { 
	LIT "# Mcout 
	STH OVR print-byte 
	DUP print-byte
	STHr DUP print-byte Mendl
}
%Mdump-buffer {
	#00
	&dump-buffer-loop 
		DUP print-byte #20 Mcout
		DUP .buf ADD LDZ DUP print-byte 
		LIT "| Mcout Mcout Mendl
		INC DUP #08 NEQ 
	?&dump-buffer-loop
	POP
}

%Msk+ { STH2kr ADD2 }
%Ms+ { STH2r ADD2 }


|0100
( init )
	;str/init print-str

	( hardcoded colors for now )
	#01 .Screen/auto DEO

	;detect-magic #08 Mbuf-next

	.Console/type DEI ?{ 
		;str/start print-str ;str/start-stdin print-str
		;on-stdin .Console/vector DEO2 
	BRK 
	}

	;read-argument .Console/vector DEO2
BRK




( i/o )


@on-stdin ( -> )
	LIT [ &index 00 ] 
	DUP .buf ADD .Console/read DEI SWP STZ
	INC DUP .buf-size-expect LDZ NEQ ?{
		( Mdump-buffer )
		( call subroutine )
		.buf-on-read LDZ2 JSR2
		.buf-on-read LDZ2 ;after-end NEQ2 ?{ 
			#0000 .Console/vector DEO2
		}
		POP #00
	}
	[ ,&index STR ]
BRK


@read-argument ( -> )
	.Console/type DEI 
	DUP #03 NEQ ?{
		;str/usage !fail-str
	}
	#02 EQU ?{ 
		#0000 .Console/vector DEO2
		;on-read-argument .Screen/vector DEO2
		BRK
	}
	.Console/read DEI 
	[ ,&name-length LDR2 ] ;filename ADD2 STA
	[ ,&name-length LDR2 ] INC2 
	DUP2 Mmax-name-length LTH2 ?{
		;str/filename-big !fail-str
	}

	[ ,&name-length STR2 ]
BRK 
	&name-length 0000


@on-read-argument ( -> )
	#0000 .Screen/vector DEO2
	;str/start print-str
	;str/start-file print-str
	;filename print-str
	Mendl
	

	;filename .File/name DEO2

	( print loop )
	&loop
		#00 .buf-size-expect LDZ .File/length DEO2
		( ;buf Mprint-short #00 .buf Mprint-short Mendl )
		;buf .File/read DEO2

		( shouldn't read more than 255 bytes )
		.File/success DEI2 #00 .buf-size-expect LDZ 
		EQU2 ?{ ;str/io-error !fail-str }


		( call subroutine )
		.buf-on-read LDZ2 JSR2

		.buf-on-read LDZ2 ;after-end NEQ2
	?&loop
BRK




( image format )


@detect-magic ( -- )
	LIT "m Mcout Mendl
	#0000
	&loop
		DUP2
		;&magic ADD2 LDA #00 EQU ?&loop-end
		DUP2 ;&magic ADD2 LDA 
		OVR .buf ADD LDZ
		DUP .Console/write DEO 
		EQU ?{ !bad-file }
		INC2 
	!&loop
	[ &magic "farbfeld 00 ]
	&loop-end

	Mendl 
	;ff-size #08 Mbuf-next
	POP2 
JMP2r


@ff-size ( -- )
	.buf/ff-w-high LDZ2 #0000 EQU2 ?{ !too-large }
	.buf/ff-w-low LDZ2 
	.buf/ff-h-high LDZ2 #0000 EQU2 ?{ !too-large }
	.buf/ff-h-low LDZ2

	handle-image-size

	;ff-palette-split0-init #08 Mbuf-next
	( ;ff-print #08 Mbuf-next )
JMP2r


@ff-reset-file ( buf-next* -- )
	;filename .File/name DEO2
	;str/start print-str
	;str/start-file print-str
	;filename print-str
	( skip the header after reset )
	#10 Mbuf-next

	#0000 .x STZ2 #0000 .y STZ2
JMP2r

	
( farbfeld uses 16-bit depth, not alpha-premultiplied ) 
( we discard the lower 10 bits )
( use 4 bits directly, if alpha is not present )
( or, multiply 2 bit color with 2 bit alpha to get 4 bits )
@ff-get-next-color ( -- r g b )
	( 255 INC becomes 0, so lambda isn't skipped -> opaque )
	.buf/ff-a LDZ DUP INC ?{
		POP
		( LIT "# Mcout )
		.buf/ff-r LDZ #04 SFT
		( DUP print-byte )
		.buf/ff-g LDZ #04 SFT
		( DUP print-byte )
		.buf/ff-b LDZ #04 SFT
		( DUP print-byte )
		( LIT "< Mcout )
		( .buf/ff-b LDZ .buf/ff-g LDZ .buf/ff-r LDZ Mprint-bgr )
	JMP2r 
	}
	#06 SFT 
	DUP .buf/ff-r LDZ #06 SFT MUL
	DUP .buf/ff-g LDZ #06 SFT MUL
	DUP .buf/ff-b LDZ #06 SFT MUL
JMP2r




( misc. )


@handle-image-size ( w* h* -- )
	;str/height print-str DUP2 Mprint-short Mendl

	DUP2k .Screen/height DEO2 .img-h STZ2
	DUP2 Mmax-h-big LTH2 ?{ !too-large }
	.Screen/height DEI2 EQU2 ?{
		( ;str/height print-str .Screen/height DEI2  )
		( Mprint-short Mendl )
		( #01 .no-fullscreen STZ )
	}

	;str/width print-str DUP2 Mprint-short Mendl

	DUP2 Mmax-w-big LTH2 ?{ !too-large }
	DUP2k .Screen/width DEO2 .img-w STZ2
	.Screen/width DEI2 EQU2 ?{
		( ;str/width print-str .Screen/width DEI2  )
		( Mprint-short Mendl )
		( #01 .no-fullscreen STZ )
	}
	( .no-fullscreen LDZ #00 EQU ?{ ;str/cannot-fullscreen !fail-str } )

	( Mmax-w-smol LTH2 ?{ 
		( memory check )
		LIT "! #ffff STA
		#ffff LDA LIT "! EQU ?{
			#01 .no-dithering STZ 
		}
		LIT "? #ffff STA
		#ffff LDA LIT "? EQU ?{
			#01 .no-dithering STZ 
		}
	}

	Mmax-w-big LTH2 ?{ 
		#01 .no-dithering STZ 
	}
	.no-fullscreen LDZ SUB ?{ ;str/cannot-fullscreen !fail-str } )
JMP2r




( image processing )

%Mpart0 { #0000 }
%Mpart1 { #00c6 }
%Mpart2 { #018c }
%Mpart3 { #0192 }
( %Mpart3 { #0258 } )

@part0
[ 
	( partition boundaries: start inclusive, end exclusive )
	&r-start 00 &r-end ff   
	&g-start 00 &g-end ff   
	&b-start 00 &b-end ff   
	( radix-sorted lists of color values )
	&r-sorted $40 &g-sorted $40 &b-sorted $40
]


@part1
	( partition boundaries: start inclusive, end exclusive )
	&r-start 00 &r-end ff
	&g-start 00 &g-end ff
	&b-start 00 &b-end ff
	( radix-sorted lists of color values )
	&r-sorted $40 &g-sorted $40 &b-sorted $40


@part2
	( partition boundaries: start inclusive, end exclusive )
	&r-start 00 &r-end ff
	&g-start 00 &g-end ff
	&b-start 00 &b-end ff
	( radix-sorted lists of color values )
	( &r-sorted $40 &g-sorted $40 &b-sorted $40 )


@part3
	( partition boundaries: start inclusive, end exclusive )
	&r-start 00 &r-end ff
	&g-start 00 &g-end ff
	&b-start 00 &b-end ff



@part-debug ( offset * -- )
	STH2
	Mendl
	LIT "R Mcout ;part0/r-start Msk+ LDA2 Mprint-short
	LIT "G Mcout ;part0/g-start Msk+ LDA2 Mprint-short
	LIT "B Mcout ;part0/b-start Msk+ LDA2 Mprint-short Mendl

	STH2kr Mpart2 NEQ2 ?{ POP2r JMP2r }
	STH2kr Mpart3 NEQ2 ?{ POP2r JMP2r }

	#0000 
	LIT "S Mcout LIT "R Mcout Mendl
	&loopr
		DUP #02 SFT 
		print-byte LIT "| Mcout
		DUP2 ;part0/r-sorted Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part0/r-sorted Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		#20 Mcout
		DUP2 
		DUP #40 SFT #00 NEQ ?{ Mendl }
		#0040 NEQ2
	?&loopr

	POP2 #0000 
	LIT "S Mcout LIT "G Mcout Mendl
	&loopg
		DUP #02 SFT 
		print-byte LIT "| Mcout
		DUP2 ;part0/g-sorted Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part0/g-sorted Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		#20 Mcout
		DUP2 
		DUP #40 SFT #00 NEQ ?{ Mendl }
		#0040 NEQ2
	?&loopg

	#0000 
	LIT "S Mcout LIT "B Mcout Mendl
	&loopb
		DUP #02 SFT 
		print-byte LIT "| Mcout
		DUP2 ;part0/b-sorted Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part0/b-sorted Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		#20 Mcout
		DUP2 
		DUP #40 SFT #00 NEQ ?{ Mendl }
		#0040 NEQ2
	?&loopb
	POP2
	Mendl POP2r
JMP2r


@part-init ( offset* -- )
	STH2
	#0000 
	&loop
		#0000 OVR2 ;part0/r-sorted ADD2 Msk+ STA2
		INC2 INC2 DUP2 #00c0 NEQ2
	?&loop
	POP2 POP2r
JMP2r


( get color variation within partition )
@part-process ( r g b offset* -- )
	STH2
	#20 SFT #00 SWP ;part0/b-sorted Msk+ ADD2 inc32-addr
	#20 SFT #00 SWP ;part0/g-sorted Msk+ ADD2 inc32-addr
	#20 SFT #00 SWP ;part0/r-sorted Ms+ ADD2 inc32-addr
JMP2r 


@part-get-max-var ( offset* -- max-var max-var-chan )
	STH2
	#00
	&find-r-min
		#00 OVR #20 SFT ;part0/r-sorted ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-r-min
		INC
	!&find-r-min
	&found-r-min
	DUP
	&find-r-max
		#00 OVR #20 SFT ;part0/r-sorted ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 is-zero32 ?&found-r-max
		INC DUP #10 LTH
	?&find-r-max
	&found-r-max
	SWP SUB
	LIT "V Mcout LIT "R Mcout DUP print-byte

	#00
	&find-g-min
		#00 OVR #20 SFT ;part0/g-sorted ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-g-min
		INC
	!&find-g-min
	&found-g-min
	DUP
	&find-g-max
		#00 OVR #20 SFT ;part0/g-sorted ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 is-zero32 ?&found-g-max
		INC DUP #10 LTH
	?&find-g-max
	&found-g-max
	SWP SUB
	LIT "V Mcout LIT "G Mcout DUP print-byte

	#00
	&find-b-min
		#00 OVR #20 SFT ;part0/b-sorted ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-b-min
		INC
	!&find-b-min
	&found-b-min
	DUP
	&find-b-max
		#00 OVR #20 SFT ;part0/b-sorted ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 is-zero32 ?&found-b-max
		INC DUP #10 LTH
	?&find-b-max
	&found-b-max
	SWP SUB
	LIT "V Mcout LIT "B Mcout DUP print-byte

	POP2r

	( wst: rvar gvar bvar )
	#03 STH
	LTHk ?{ POPr #02 STH SWP } NIP
	LTHk ?{ POPr #01 STH SWP } NIP
	STHr
JMP2r


@part-get-median ( buffer* div -- median )
	Mendl Mendl
	#00 SWP .img-w LDZ2 .img-h LDZ2 mul16 
	ROT2 NIP shift32-0 
	[ ,&midl STR2 ] [ ,&midh STR2 ]
	DUP2 #0000 #0000 ROT2
	&loop ( buffer* sumh* suml* ptr* )
		( LIT ". Mcout )
		LDA2k SWP2 INC2 INC2 LDAk2 SWP2 STH2 add32
		OVR2 OVR2
		[ LIT2 &midh 0000 LIT2 &midl 0000 ] lt32 ?{ 
			POP2 POP2 STH2r SWP2 SUB2 #02 SFT2 NIP
			( correction for when median is in first chunk )
			DUP ?{ POP #01 }
			JMP2r	
		}
		STH2r INC2 INC2
	!&loop
!fail


@ff-palette-split0-init ( -- )
	Mpart0 part-init
	;ff-palette-split0 #08 Mbuf-next
	ff-palette-split0 
	( jump to instruction immediately because the header 
	  had already been read )
JMP2r


@ff-palette-split0 ( -- )
	ff-get-next-color ( r g b )

	Mpart0 part-process

	advance-pos ?{
		Mpart0 part-get-max-var
		DUP #01 NEQ ?{
			;part0/r-sorted #01 part-get-median
			DUP ;part0/r-end STA
			;part1/r-start STA
			!&done
		}
		DUP #02 NEQ ?{
			;part0/g-sorted #01 part-get-median
			DUP ;part0/g-end STA
			;part1/g-start STA
			!&done
		}
		;part0/b-sorted #01 part-get-median
		DUP ;part0/b-end STA
		;part1/b-start STA
		&done
		Mpart0 part-debug
		( Mpart1 part-debug )
		
		LIT "? Mcout
		;ff-palette-split1-init ff-reset-file
	}
JMP2r


( TODO potentially optimize: not check every part on every step )
@get-partition ( r g b -- r g b p )
	DUP ;part0/b-start LDA SWP GTH ?&part1
	DUP ;part0/b-end LDA LTH ?{ !&part1 }

	SWP DUP ;part0/g-start LDA SWP GTH ?{ !&g0 } SWP !&part1
	&g0 DUP ;part0/g-end LDA LTH ?{ SWP !&part1 } SWP

	ROT DUP ;part0/r-start LDA SWP GTH ?{ !&r0 } ROT ROT !&part1
	&r0 DUP ;part0/r-end LDA LTH ?{ ROT ROT !&part1 } ROT ROT
	#00 JMP2r	

	&part1
	DUP ;part1/b-start LDA SWP GTH ?&part2
	DUP ;part1/b-end LDA LTH ?{ !&part2 }

	SWP DUP ;part1/g-start LDA SWP GTH ?{ !&g1 } SWP !&part2
	&g1 DUP ;part1/g-end LDA LTH ?{ SWP !&part2 } SWP

	ROT DUP ;part1/r-start LDA SWP GTH ?{ !&r1 } ROT ROT !&part2
	&r1 DUP ;part1/r-end LDA LTH ?{ ROT ROT !&part2 } ROT ROT
	#01 JMP2r	

	&part2
	DUP ;part2/b-start LDA SWP GTH ?&part3
	DUP ;part2/b-end LDA LTH ?{ !&part3 }

	SWP DUP ;part2/g-start LDA SWP GTH ?{ !&g2 } SWP !&part3
	&g2 DUP ;part2/g-end LDA LTH ?{ SWP !&part3 } SWP

	ROT DUP ;part2/r-start LDA SWP GTH ?{ !&r2 } ROT ROT !&part3
	&r2 DUP ;part2/r-end LDA LTH ?{ ROT ROT !&part3 } ROT ROT
	#02 JMP2r	

	&part3
	#03
JMP2r


@ff-palette-split1-init ( -- )
	Mpart0 part-init
	Mpart1 part-init
	;ff-palette-split1 #08 Mbuf-next
JMP2r


@ff-palette-split1 ( -- )
	ff-get-next-color ( r g b )
	( Mprint-rgb ff-get-next-color )

	get-partition ?{
		Mpart0 part-process !&processed
	}
	Mpart1 part-process

	&processed

	advance-pos ?{
		( Mpart0 part-debug )
		Mpart0 part-get-max-var

		DUP #01 NEQ ?{
			LIT "% Mcout
			;part0/r-sorted #02 part-get-median
			DUP ;part0/r-end STA
			;part2/r-start STA
			;part0/g-start LDA ;part2/g-start STA
			;part0/g-end LDA ;part2/g-end STA
			;part0/b-start LDA ;part2/b-start STA
			;part0/b-end LDA ;part2/b-end STA
			!&part0-done
		}
		DUP #02 NEQ ?{
			;part0/r-start LDA ;part2/r-start STA
			;part0/r-end LDA ;part2/r-end STA
			;part0/g-sorted #02 part-get-median
			DUP ;part0/g-end STA
			;part2/g-start STA
			;part0/b-start LDA ;part2/b-start STA
			;part0/b-end LDA ;part2/b-end STA
			!&part0-done
		}
		;part0/r-start LDA ;part2/r-start STA
		;part0/r-end LDA ;part2/r-end STA
		;part0/g-start LDA ;part2/g-start STA
		;part0/g-end LDA ;part2/g-end STA
		;part0/b-sorted #02 part-get-median
		DUP ;part0/b-end STA
		;part2/b-start STA

		&part0-done

		( Mpart1 part-debug )
		Mpart1 part-get-max-var


		DUP #01 NEQ ?{
			;part1/r-sorted #02 part-get-median
			DUP ;part1/r-end STA
			;part3/r-start STA
			;part1/g-start LDA ;part3/g-start STA
			;part1/g-end LDA ;part3/g-end STA
			;part1/b-start LDA ;part3/b-start STA
			;part1/b-end LDA ;part3/b-end STA
			!&part1-done
		}
		DUP #02 NEQ ?{
			;part1/r-start LDA ;part3/r-start STA
			;part1/r-end LDA ;part3/r-end STA
			;part1/g-sorted #02 part-get-median
			DUP ;part1/g-end STA
			;part3/g-start STA
			;part1/b-start LDA ;part3/b-start STA
			;part1/b-end LDA ;part3/b-end STA
			!&part1-done
		}
		;part1/r-start LDA ;part3/r-start STA
		;part1/r-end LDA ;part3/r-end STA
		;part1/g-start LDA ;part3/g-start STA
		;part1/g-end LDA ;part3/g-end STA
		;part1/b-sorted #02 part-get-median
		DUP ;part1/b-end STA
		;part3/b-start STA
		&part1-done

		Mpart0 part-debug
		Mpart1 part-debug
		Mpart2 part-debug
		Mpart3 part-debug
		
		;ff-sum-colors-init ff-reset-file
	}
JMP2r


@ff-sum-colors-init ( -- )
	;ff-sum-colors #08 Mbuf-next
JMP2r


( &r &g &b are 16-bit values containing sum of values of colors,
  &n is count of values 
  2^12 values are storable; when n reaches 4096 we divide and add
  avg value to &rh
  we then count "average of averages"
  )
@ff-sum-colors ( -- )
	ff-get-next-color
	get-partition #00 SWP #40 SFT STH2
	#00 SWP ;&b Msk+ LDAk2 ROT2 ADD2 SWP2 STA2
	#00 SWP ;&g Msk+ LDAk2 ROT2 ADD2 SWP2 STA2
	#00 SWP ;&r Msk+ LDAk2 ROT2 ADD2 SWP2 STA2
	;&n Msk+ LDA2 INC2
	DUP2 #1000 LTH2 ?{
		POP2
		;&r Msk+ LDA2 #0c SFT2 ;&rh Msk+ LDA2 ADD2 
		;&rh Msk+ STA2 #0000 ;&r Msk+ STA2
		;&g Msk+ LDA2 #0c SFT2 ;&gh Msk+ LDA2 ADD2 
		;&gh Msk+ STA2 #0000 ;&g Msk+ STA2
		;&b Msk+ LDA2 #0c SFT2 ;&bh Msk+ LDA2 ADD2 
		;&bh Msk+ STA2 #0000 ;&b Msk+ STA2
		#0000 ;&n Msk+ STA2 ;&nh Msk+ LDA2k INC2 
		SWP2 STA2
		!&done
	} 
	;&n Msk+ STA2

	&done
	POP2r
	advance-pos ?{ 
		ff-avg-colors
	}
JMP2r
	&r $2 &rh $2 &g $2 &gh $2 &b $2 &bh $2 &n $2 &nh $2
	@sum1 [ &r $2 &rh $2 &g $2 &gh $2 &b $2 &bh $2 &n $2 &nh $2 ]
	@sum2 [ &r $2 &rh $2 &g $2 &gh $2 &b $2 &bh $2 &n $2 &nh $2 ]
	@sum3 [ &r $2 &rh $2 &g $2 &gh $2 &b $2 &bh $2 &n $2 &nh $2 ]


@ff-avg-color ( {chan}* {n}* -- avg-color )
	STH2
	#0000 SWP2 LDA2k ( low )
	LIT "L Mdebug-short
	#0000 ROT2 INC2 INC2 LDA2 #0c lshift32 ( high )
	LIT "H Mdebug32
	add32
	LIT "= Mdebug32 Mendl

	#0000 STH2r
	LDA2k ( low n )
	LIT "n Mdebug-short
	#0000 ROT2 INC2 INC2 LDA2 #0c lshift32 ( high n )
	LIT "N Mdebug32
	add32
	LIT "= Mdebug32 Mendl
	div32
	LIT "= Mdebug32 Mendl


	SWP #00 EQU ?{ !fail }
	SWP #00 EQU ?{ !fail }
	SWP #00 EQU ?{ !fail }
JMP2r


@ff-avg-colors ( -- )
	LIT "0 Mcout Mendl
	LIT "r Mcout Mendl
	;ff-sum-colors/r ;ff-sum-colors/n ff-avg-color .color0/r STZ
	LIT "g Mcout Mendl
	;ff-sum-colors/g ;ff-sum-colors/n ff-avg-color .color0/g STZ
	LIT "b Mcout Mendl
	;ff-sum-colors/b ;ff-sum-colors/n ff-avg-color .color0/b STZ

	LIT "1 Mcout Mendl
	LIT "r Mcout Mendl
	;sum1/r ;sum1/n ff-avg-color .color1/r STZ
	LIT "g Mcout Mendl
	;sum1/g ;sum1/n ff-avg-color .color1/g STZ
	LIT "b Mcout Mendl
	;sum1/b ;sum1/n ff-avg-color .color1/b STZ

	LIT "2 Mcout Mendl
	LIT "r Mcout Mendl
	;sum2/r ;sum2/n ff-avg-color .color2/r STZ
	LIT "g Mcout Mendl
	;sum2/g ;sum2/n ff-avg-color .color2/g STZ
	LIT "b Mcout Mendl
	;sum2/b ;sum2/n ff-avg-color .color2/b STZ

	LIT "3 Mcout Mendl
	LIT "r Mcout Mendl
	;sum3/r ;sum3/n ff-avg-color .color3/r STZ
	LIT "g Mcout Mendl
	;sum3/g ;sum3/n ff-avg-color .color3/g STZ
	LIT "b Mcout Mendl
	;sum3/b ;sum3/n ff-avg-color .color3/b STZ

	prepare-palette

	;ff-print-init ff-reset-file
JMP2r



( printing )


@ff-print-init
	;ff-print #08 Mbuf-next
JMP2r


@ff-print ( -- )
	ff-get-next-color ( r g b )
	pick-color .Screen/pixel DEO
	advance-pos-screen ?{
		;str/end print-str 
		;after-end .buf-on-read STZ2
	}
JMP2r


@prepare-palette
	LIT "0 Mcout
	;color0/b LDA ;color0/g LDA ;color0/r LDA Mprint-bgr
	LIT "1 Mcout
	;color1/b LDA ;color1/g LDA ;color1/r LDA Mprint-bgr
	LIT "2 Mcout
	;color2/b LDA ;color2/g LDA ;color2/r LDA Mprint-bgr
	LIT "3 Mcout
	;color3/b LDA ;color3/g LDA ;color3/r LDA Mprint-bgr

	;color0/r LDA DUP ;pick-color/color0r STA #40 SFT 
	;color1/r LDA DUP ;pick-color/color1r STA ORA [ ,&rhigh STR ]
	;color2/r LDA DUP ;pick-color/color2r STA #40 SFT
	;color3/r LDA DUP ;pick-color/color3r STA ORA [ ,&rlow STR ]
	;color0/g LDA DUP ;pick-color/color0g STA #40 SFT 
	;color1/g LDA DUP ;pick-color/color1g STA ORA [ ,&ghigh STR ]
	;color2/g LDA DUP ;pick-color/color2g STA #40 SFT
	;color3/g LDA DUP ;pick-color/color3g STA ORA [ ,&glow STR ]
	!{
		&r &rhigh 00 &rlow 00
		&g &ghigh 00 &glow 00
		&b &bhigh 00 &blow 00
	}
	;color0/b LDA DUP ;pick-color/color0b STA #40 SFT 
	;color1/b LDA DUP ;pick-color/color1b STA ORA [ ,&bhigh STR ]
	;color2/b LDA DUP ;pick-color/color2b STA #40 SFT
	;color3/b LDA DUP ;pick-color/color3b STA ORA [ ,&blow STR ]

	LIT "R Mcout [ ,&r LDR2 ] Mprint-short
	LIT "G Mcout [ ,&g LDR2 ] Mprint-short
	LIT "B Mcout [ ,&b LDR2 ] Mprint-short
	Mendl

	[ ,&r LDR2 ] .System/r DEO2
	[ ,&g LDR2 ] .System/g DEO2
	[ ,&b LDR2 ] .System/b DEO2
JMP2r


( chooses closest color from palette )
@pick-color ( r g b -- c )
	ROTk ROTk ROTk 
	( r g b g b r b r g r g b )
	[ LIT &color0b $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color0g $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color0r $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 POP2 POP2 POP2 #00 JMP2r }
	[ ,&diff0 STR ]

	( r g b g b r b r g )
	[ LIT &color1g $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color1r $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color1b $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 POP2 POP #01 JMP2r }
	[ ,&diff1 STR ]

	( r g b g b r )
	[ LIT &color2r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color2b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color2g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 #02 JMP2r }
	[ ,&diff2 STR ]

	( r g b )
	[ LIT &color3b $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color3g $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color3r $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #03 JMP2r }

	#03 SWP
	( wst: cur-min-col cur-min )
	[ LIT &diff0 $1 ] LTHk ?{ NIP #00 SWP ROT } POP
	[ LIT &diff1 $1 ] LTHk ?{ NIP #01 SWP ROT } POP
	[ LIT &diff2 $1 ] LTH ?{ POP #02 }
JMP2r


@advance-pos ( -- continue )
	( LIT "x Mcout .x LDZ2 Mprint-short )
	( LIT "y Mcout .y LDZ2 Mprint-short Mendl )
	.x LDZ2 INC2 .img-w LDZ2 NEQ2k ?{
		POP2 POP2 #0000 .x STZ2
		.y LDZ2 INC2
		DUP2 .y STZ2
		.img-h LDZ2 NEQ2
	JMP2r }
	POP2 .x STZ2
	#01
JMP2r


( assumes screen auto )
@advance-pos-screen ( -- continue )
	.Screen/x DEI2 .img-w LDZ2 NEQ2 ?{
		#0000 .Screen/x DEO2 
		.Screen/y DEI2 INC2 
		DUP2 .Screen/y DEO2 
		.img-h LDZ2 NEQ2
	JMP2r }
	#01
JMP2r




( end )


@after-end ( -- )
	;str/after-end print-str	
JMP2r



( errors )
	

@bad-file 
	;&str 
!fail-str
	&str "...Bad 20 "file 00


@too-large
	;&str 
!fail-str
	&str "...Too 20 "large 00


@fail-str ( error-msg* -> )
	print-str
( -> )
@fail ( -> )
	LIT "! Mcout
	#01 .System/state DEO
BRK

@str [
	&init "Hello! 0a 00
	&start "Reading 20 00
	&start-file "file: 20 00
	&start-stdin "standard 20 "input... 0a 00
	&end "Готово! 0a 00
	&usage "Usage: 20 "svitlyna.rom 20 "image.ff 0a 00
	&cannot-fullscreen "Unable 20 "to 20 "resize 20 "screen. 0a 00
	&width "w: 20 00
	&height "h: 20 00
	&after-end "Warning: 20 
	           "input 20 "after 20 "image 20 "end. 0a 00
	&filename-big "File 20 "name 20 "too 20 "big. 0a 00
	&divided-colors "Divided 20 "colors. 0a 00
	&io-error "I/O 20 "error 0a 20 00
]




( utils and stdlib )


@print-str ( str* -- )
	&while ( -- )
		LDAk .Console/write DEO
		INC2 LDAk 
	?&while
	POP2 
JMP2r

@print-byte ( b -- )
	DUP #04 SFT DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO

	#0f AND DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO
JMP2r

@inc32-addr ( addr* -- )
	DUP2 INC2 INC2 LDA2 INC2 ( inc lower short )
	DUP2 #0000 NEQ2 ?{
		POP2 LDA2k INC2 OVR2 STA2 ( inc upper short )
		#0000 SWP2 INC2 INC2 STA2 
		JMP2r 
	}
	SWP2 INC2 INC2 STA2	
JMP2r




( http://plastic-idolatry.com/erik/nxu/math32.tal )


@bitcount16 ( x* -> n^ )
    LITr 00 &loop ORAk ?{ POP2 STHr JMP2r } #01 SFT2 INCr !&loop

@bitcount32 ( x** -> n^ )
    SWP2 bitcount16 DUP ?{ POP !bitcount16 } #10 NIP2 ADD JMP2r

( x == 0 )
@is-zero32 ( x** -> bool^ )
    ORA2 #0000 EQU2 JMP2r

( x != 0 )
@non-zero32 ( x** -> bool^ )
    ORA2 ORA JMP2r

( x + y )
@add32 ( xhi* xlo* yhi* ylo* -> zhi* zlo* )
    ROT2 STH2k ADD2 STH2k ROT2 ROT2 GTH2r #00 STHr ADD2 ADD2 SWP2 JMP2r

( x - y )
@sub32 ( x** y** -> z** )
    ROT2 STH2k SWP2 SUB2 STH2k ROT2 ROT2 LTH2r #00 STHr ADD2 SUB2 SWP2 JMP2r

( 16-bit multiplication )
@mul16 ( x* y* -> z** )
    ,&y1 STR ,&y0 STR ( save ylo, yhi )
    ,&x1 STR ,&x0 STR ( save xlo, xhi )
    #0000 ,&z1 STR ,&w0 STR ( reset z1 and w0 )

    ( x1 * y1 => z1z2 )
    LIT2 00 [ &x1 $1 ] LIT2 00 [ &y1 $1 ] MUL2 ,&z3 STR ,&z2 STR

    ( x0 * y1 => z0z1 )
    #00 ,&x0 LDR #00 ,&y1 LDR MUL2 ,&z1 LDR2 ADD2 ,&z1 STR2

    ( x1 * y0 => w1w2 )
    #00 ,&x1 LDR #00 ,&y0 LDR MUL2 ,&w2 STR ,&w1 STR

    ( x0 * y0 => w0w1 )
    LIT2 00 [ &x0 $1 ] LIT2 00 [ &y0 $1 ] MUL2 ,&w0 LDR2 ADD2 ,&w0 STR2

    ( add z and a<<8 )
    #00 LIT2 [ &z1 $1 &z2 $1 ] LIT [ &z3 $1 ]
    LIT2 [ &w0 $1 &w1 $1 ] LIT [ &w2 $1 ] #00
    !add32

( x * y )
@mul32 ( x** y** -> z** )
    ROT2k ( x0* x1* y0* y1* y0* y1* x1* )
    mul16 ,&z1 STR2 ,&z0 STR2 POP2 ( x0* x1* y0* y1* ; sum = [x1*y1] )
    STH2 ROT2 STH2                 ( x1* y0* [y1* x0*] )
    MUL2r MUL2 STH2r ADD2          ( x1*y0+y1*x0* )
    ( [x0*y0]<<32 will completely overflow )
    LIT2 [ &z0 $2 ] ADD2 ( sum += [x0*y1+x1*y0]<<16 )
    LIT2 [ &z1 $2 ] JMP2r

( x >> n )
@rshift32 ( x** n^ -> x>>n )
    DUP #08 LTH ?shift32-0 ( x n )
    DUP #10 LTH ?rshift32-1 ( x n )
    DUP #18 LTH ?rshift32-2 ( x n )
    !rshift32-3 ( x n )

( shift by 0-7 bits; used by both lshift and rshift )
@shift32-0 ( x** n^ -> x>>n )
    STH DUP2 STHkr SFT2                       ,&z2 STR2
    POP DUP2 STHkr SFT2 ,&z2 LDR ORA ,&z2 STR ,&z1 STR
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    LIT [ &z1 $1 ] LIT2 [ &z2 $2 ] JMP2r

( x << n )
@lshift32 ( x** n^ -> x<<n )
    DUP #08 LTH ?lshift32-0 ( x n )
    DUP #10 LTH ?lshift32-1 ( x n )
    DUP #18 LTH ?lshift32-2 ( x n )
    !lshift32-3 ( x n )

( shift right by 8-15 bits )
@rshift32-1 ( x** n^ -> x>>n )
    #08 SUB STH                 ( stash [n>>8] )
    POP DUP2 STHkr SFT2 ,&z2 STR2
    POP      STHr  SFT2 ,&z2 LDR ORA ,&z2 STR
    #00 SWP LIT2 [ &z2 $2 ] JMP2r

( shift right by 16-23 bits )
@rshift32-2 ( x** n^ -> x>>n )
    #10 SUB STH                 ( stash [n>>16] )
    POP2 STHr SFT2 #0000 SWP2 JMP2r

( shift right by 16-23 bits )
@rshift32-3 ( x** n^ -> x>>n )
    #18 SUB STH                 ( stash [n>>24] )
    POP2 POP STH SWPr SFTr #00 #0000 STHr JMP2r

( shift left by 0-7 bits )
@lshift32-0 ( x** n^ -> x<<n )
    #40 SFT !shift32-0

( shift left by 8-15 bits )
@lshift32-1 ( x** n^ -> x<<n )
    #08 SUB #40 SFT STH ( stash [n-8]<<4 )
        DUP2 STHkr SFT2 ,&z1 STR2
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    NIP LIT2 [ &z1 $1 &z2 $1 ] #00 JMP2r

( shift left by 16-23 bits )
@lshift32-2 ( x** n^ -> x<<n )
    #10 SUB #40 SFT STH ( stash [n-16]<<4 )
    NIP2 STHr SFT2 #0000 JMP2r

( shift left by 24-31 bits )
@lshift32-3 ( x** n^ -> x<<n )
    #18 SUB #40 SFT ( stash [n-24]<<4 )
    SFT NIP2 NIP #0000 #00 JMP2r

( x < y )
@lt32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 JMP2r } GTH2 #00 EQU JMP2r

( x > y )
@gteq32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 #00 EQU JMP2r } GTH2 JMP2r

( x / y )
@div32 ( x** y** -> q** )
    z_divmod32 ;z_divmod32/quo0 LDA2 ;z_divmod32/quo1 LDA2 JMP2r

( x % y )
@mod32 ( x** y** -> r** )
    z_divmod32 ;z_divmod32/rem0 LDA2 ;z_divmod32/rem1 LDA2 JMP2r

( x / y, x % y )
@divmod32 ( x** y** -> q** r** )
    z_divmod32
    ;z_divmod32/quo0 LDA2 ;z_divmod32/quo1 LDA2
    ;z_divmod32/rem0 LDA2 ;z_divmod32/rem1 LDA2
    JMP2r

( private: calculate and store x / y and x % y )
@z_divmod32 ( x** y** -> )
    ( ; store y and x for repeated use )
    #0000 DUP2 ,&quo0 STR2 ,&quo1 STR2      ( x** y**         ; quo<-0 )
    STH2k ,&div1 STR2 STH2k ,&div0 STR2     ( x** [ylo* yhi*] ; div<-y )
    OVR2 OVR2 ,&rem1 STR2 ,&rem0 STR2       ( x** [ylo* yhi*] ; rem<-x )
    OVR2 OVR2 STH2r STH2r                   ( x** x** y** )
    OVR2 OVR2 STH2 STH2                     ( x** x** y** [ylo* yhi*] )
    gteq32 ?{ POP2 POP2 POP2r POP2r JMP2r } ( x** [ylo* yhi*] ; return if x < y )

    ( ; bitcount[x] - bitcount[y] determines largest multiple of y to try )
    bitcount32 STH2r STH2r bitcount32 SUB ( shift=rbits-dits^ )
    #00 DUP2                              ( shift^ 0^ shift^ 0^ )
    #0000 INC2k ROT2 POP                  ( shift^ 0^ 0* 1* shift^ )
    lshift32 ,&cur1 STR2 ,&cur0 STR2      ( shift^ 0^ ; cur<-1<<shift )
    ,&div0 LDR2 ,&div1 LDR2 ROT2 POP      ( div** shift^ )
    lshift32 ,&div1 STR2 ,&div0 STR2      ( ; div<-div<<shift )

    &loop
      ( ; if rem >= cur [current divisor], we can subtract it and add to quotient )
      ( ; otherwise, skip that iteration and reduce cur. )
      LIT2 [ &rem0 $2 ] LIT2 [ &rem1 $2 ] ,&div0 LDR2 ,&div1 LDR2
      lt32 ?{
        ( ; since rem >= div, we have found a multiple of y that divides x )
        ,&rem0 LDR2 ,&rem1 LDR2             ( rem** )
        LIT2 [ &div0 $2 ] LIT2 [ &div1 $2 ] ( rem** div** )
        sub32 ,&rem1 STR2 ,&rem0 STR2       ( ; rem<-rem-div** )
        LIT2 [ &quo0 $2 ] LIT2 [ &quo1 $2 ] ( quo** )
        LIT2 [ &cur0 $2 ] LIT2 [ &cur1 $2 ] ( quo** cur** )
        add32 ,&quo1 STR2 ,&quo0 STR2       ( ; quo<-quo+cur** )
      }
      ,&div0 LDR2 ,&div1 LDR2 #01 rshift32 ( div>>1** )
      ,&div1 STR2 ,&div0 STR2              ( ; div<-div>>1 )
      ,&cur0 LDR2 ,&cur1 LDR2 #01 rshift32 ( cur>>1** )
      OVR2 OVR2 ,&cur1 STR2 ,&cur0 STR2    ( cur>>1** ; cur<-cur>>1 )
      non-zero32 ?&loop JMP2r              ( ; loop if cur>0, else we're done )


|7000 @filename


(   lines: #8000-#ec00
           0x0c00 = 3072 bytes per line
           3072 / 3 * 4 = 4096 pixels per line
  sprites: #ec00-#f000
           0x0400 = 1024 bytes total
           1024 * 4 = 4096 pixels per line )
|8000 @lines-big
|ec00 @sprite-big
