|00 @System [ 
	&vector $2 &expansion $2 &wst $1 &rst $1 
	&metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1 
]
|10 @Console [ 
	&vector $2 &read $1
	$4 
	&type $1 &write $1 &error $1
]
|20 @Screen [ 
	&vector $2 &width $2 &height $2 &auto $1
	$1 
	&x $1 &x-l $1 &y $1 &y-l $1 &addr $2 &pixel $1 &sprite $1
]
|80 @Controller [
	&vector $2 &button $1 &key $1
]
|90 @Mouse [
	&vector $2 &x $2 &y $2 &state $1
	$3
	&scrollx $2 &scrolly $2
]
|a0 @File [ 
	&vector $2 &success $2 &stat $2 &delete $1 
	&append $1 &name $2 &length $2 &read $2 &write $2
]

|0000 

( color channels )
%Mr { #00 } %Mg { #01 } %Mb { #02 }

@decode-x $2 @decode-y $2 
@xfrac $2 @yfrac $2
@img-w $2 @img-h $2 @img-size $4

%Mmax-width { #1000 }
%Mmax-height { #1000 }
%Mmax-name-length { #07ff }

( 8-bit linear RGB colors, used for most processing )
( display device palette is in sRGB )
@color0 [ &r $1 &g $1 &b $1 ]
@color1 [ &r $1 &g $1 &b $1 ]
@color2 [ &r $1 &g $1 &b $1 ]
@color3 [ &r $1 &g $1 &b $1 ]
( extra 4 colors, only used with uxn38 )
@color4 [ &r $1 &g $1 &b $1 ]
@color5 [ &r $1 &g $1 &b $1 ]
@color6 [ &r $1 &g $1 &b $1 ]
@color7 [ &r $1 &g $1 &b $1 ]
@color-min [ &r $1 &g $1 &b $1 ]
@color-max [ &r $1 &g $1 &b $1 ]

( based on @palettes/kwgb )
( k w g b (m=unused) r c y )
%Muxn38-r { #05 }
%Muxn38-g { #02 }
%Muxn38-b { #03 }
%Muxn38-w { #01 }
%Muxn38-c { #06 }
%Muxn38-m { #04 }
%Muxn38-y { #07 }
%Muxn38-k { #00 }

%Mfile-buffer-length { #4000 }


@part-split-step $1
@current-palette $2
@current-mode $1
%Mmode-streaming { #01 }
%Mmode-no-dithering { #02 }
%Mmode-partition-color-func { #04 }
@mode-uxn38 $1

%Mcout { .Console/write DEO }
%Mendl { #0a Mcout }

%Mprint-short { SWP print-byte print-byte }
%Mdebug-byte { Mcout DUP print-byte }
%Mdebug-short { Mcout OVR print-byte DUP print-byte }
%Mdebug32 { Mcout OVR2 Mprint-short DUP2 Mprint-short }
%Mdebug-rgb { 
	Mcout LIT "# Mcout 
	ROT DUP print-byte 
	ROT DUP print-byte
	ROT DUP print-byte
}

%Mprint-bgr { 
	LIT "# Mcout 
	print-byte print-byte print-byte
}
%Mprint-rgb { 
	LIT "# Mcout 
	ROT print-byte SWP print-byte print-byte
}

( common pattern for adding offset to pointer )
%Msk+ { STH2kr ADD2 }
%Ms+ { STH2r ADD2 }

%Mload32 { LDA2k SWP2 INC2 INC2 LDA2 }
%Mnon-zero2 { ORA }


|0100
( init )
	( memory check )
	;str/memory-check print-str
	;end Mprint-short
	#1234 ;end STA2
	;end LDA2 #1234 EQU2 ?{ ;str/memory-error !fail-str }
	LIT 20 Mcout LIT "O Mcout LIT "K Mcout Mendl

	;str/init print-str

	;on-controller-input .Controller/vector DEO2
	( ;on-mouse .Mouse/vector DEO2 )

	;ext-uxn38-fg-color .System/expansion DEO2
	;ext-uxn38-fg-color/v LDA 
	DUP #02 LTH ?{ ;str/unexpected-ext !fail-str }
	.mode-uxn38 STZ

	.Console/type DEI ?{ 
		;read-stdin .Console/vector DEO2	
		.mode-uxn38 LDZ ?{
			;palettes/bw .current-palette STZ2
			prepare-palette-builtin
			!&palette-chosen
		}
		;palettes/kwgb .current-palette STZ2
		prepare-palette-uxn38
		&palette-chosen
		Mmode-streaming .current-mode STZ
		;str/read print-str ;str/read-stdin print-str

		;detect-magic set-on-bytes-received
		#0008 set-bytes-expected
		;display set-on-pixel-received

		!display-init
	}
	;read-argument .Console/vector DEO2
	BRK
	

( Excerpt from uxn11 documentation: 
  This describes the nonstandard "03 extensions" command )

( The parts of the command are:

* Command code: Always 0x03.

* Device number: A command that does not load or override a device into a
device slot is zero, otherwise it is a nonzero multiple of sixteen. Some
extensions and some implementations may have further restrictions. If this
number is not a multiple of sixteen (but must be at least sixteen), then
the low nybble indicates how many additional consecutive devices to be
affected; e.g. #33 means to affect all four audio devices (the high nybble
is 3 for the first audio device, and the low nybble 3 means the other 3).

* UUID: Sixteen bytes, which identifies the extension.

* Version: One byte. The emulator writes a nonzero value here (the specific
value is defined by the extension) if it is supported in this mode with
this device number and other parameters, or zero if it is not implemented.
(The uxn program should put zero here by default, so that if running on an
emulator that doesn't process the 03 command at all, it will work.)

* Extra data: The number of bytes and meaning is defined by the specific
extension; this may be read-only, write-only, or some combination. If the
extension is not implemented, then the emulator MUST ignore it and MUST NOT
attempt to write anything here, and MUST NOT override any devices.

An example of how to use this:

  @load-ext1 ;ext1 #02 DEO2 ;ext1/v LDA JMP2r
  @ext1 03 d0 <uuid> &v 00

This example does not use any extra data, and selects an extension for
device #d0. The <uuid> must be replaced by the appropriate sixteen-byte
UUID for the extension being selected. )

( Allows setting separate foreground and background colours. The device
number must be zero, and the version will be 1. The data is eight 16-bit
numbers, for the colours in order background 0 to 3 and then foreground 0
to 3 (although note that foreground 0 is not normally meaningful), with the
high to low nybble of each being red, green, blue, unused (zero). What
happens if you then try to change colours using the colour ports after
doing this, is not specified. )
@ext-uxn38-fg-color [ 
	03 00 
	8017 5132 e263 11ed b8c9 0026 1874 5416 
	&v 00 
	( k w g b (m=unused) r c y )
	0000 fff0 0f00 00f0 f0f0 f000 0ff0 ff00
]


@read-stdin ( -> )
	[ LIT2 &index 0000 ] 
	DUP2 ;file-buf ADD2 
	.Console/read DEI ROT ROT STA
	INC2 DUP2 [ LIT2 &bytes-expected $2 ] NEQ2 ?{
		( call subroutine )
		;file-buf [ LIT2 &on-bytes-received $2 ] JSR2
		POP2 #0000 [ ,&index STR2 ]
		BRK
	}
	[ ,&index STR2 ]
	BRK


@read-argument ( -> )
	.Console/type DEI 
	DUP #03 NEQ ?{
		;str/usage !fail-str
	}
	#02 EQU ?{ 
		#00 [ ,&name-length LDR2 ] ;filename ADD2 STA
		Mendl
		
		.mode-uxn38 LDZ ?{
			;palettes/detected-from-img .current-palette STZ2
			!palette-split-init
		}
		;palettes/kwgb .current-palette STZ2
		prepare-palette-uxn38
		!display-init
	}
	.Console/read DEI 
	[ ,&name-length LDR2 ] ;filename ADD2 STA
	[ ,&name-length LDR2 ] INC2 
	DUP2 Mmax-name-length LTH2 ?{
		;str/filename-big !fail-str
	}

	[ ,&name-length STR2 ]
	BRK 
&name-length 0000


@read-file ( -> )
	;str/read print-str ;str/read-file print-str
	;filename print-str Mendl

	;detect-magic set-on-bytes-received
	#0008 set-bytes-expected

	;filename .File/name DEO2
	Mfile-buffer-length .File/length DEO2

	;file-buf ;read-buffer/window STA2
	;read-buffer .Screen/vector DEO2
	BRK


@read-buffer ( -> )
	;file-buf 
	DUP2 .File/read DEO2
	.File/success DEI2 ADD2 [ ,&window-end STR2 ]

	&loop
		[ LIT2 &window =file-buf ] 
		DUP2 [ LIT2 &bytes-expected $2 ] ADD2 ( next window )
		[ LIT2 &window-end =file-buf/end ]
		GTH2k ?{
			POP2
			[ ,&window STR2 ]
			[ LIT2 &on-bytes-received $2 ] JSR2
			!&loop

			( copy cmd )
			&cmd [ 
				01 0020 0000 =file-buf/pre-end 
				0000 =file-buf-pre 
			]
		}
		( not enough bytes )

		;file-buf/end NEQ2 ?{
			( buffer full )
			( copy last 20 bytes to pre-buffer )
			;&cmd .System/expansion DEO2
			POP2
			Mfile-buffer-length SUB2 [ ,&window STR2 ]

			( a good time to take a break? )
			[ LIT &break-counter 00 ] INC
			DUP #10 NEQ ?{
				POP #00 [ ,&break-counter STR ]
				BRK	
			}
			[ ,&break-counter STR ]
			!read-buffer
		}
		#0000 .Screen/vector DEO2
		[ LIT2 &on-file-end $2 ] JMP2


@set-on-bytes-received ( {routine}* -- )
	DUP2 ;read-buffer/on-bytes-received STA2
	     ;read-stdin/on-bytes-received STA2
	JMP2r


@set-bytes-expected ( bytes* -- )
	DUP2 ;read-buffer/bytes-expected STA2
	     ;read-stdin/bytes-expected STA2
	JMP2r


@set-on-pixel-received ( bytes* -- )
	DUP2 ;ff-next-pixel/on-pixel-received STA2
	     ;qoi-on-pixel-received/routine STA2
	JMP2r


@set-on-file-end ( bytes* -- )
	;read-buffer/on-file-end STA2
	JMP2r




( ui )

@on-controller-input ( -> )
	.Controller/button DEI 		
	DUP #01 AND ?on-a-ctrl
	DUP #02 AND ?on-b-alt
	DUP #10 AND ?on-dpad-up
	    #20 AND ?on-dpad-down
	BRK


@on-a-ctrl ( -> )
	Mmode-streaming is-mode ?end
	[ LIT2 00 -mode-uxn38 ] STZ
	;palettes/detected-from-img .current-palette STZ2

	.part-split-step LDZ [ #03 ] EQU ?{
		!palette-split-init
	}

	prepare-palette-avg
	!display-init


@on-b-alt ( -> )
	Mmode-streaming is-mode ?end
	.current-palette LDZ2 ;palettes/detected-from-img NEQ2 ?{ 
		Mmode-partition-color-func is-mode ?{
			Mmode-partition-color-func #01 set-mode
			!display-init
		}
		Mmode-partition-color-func #00 set-mode
		( also toggle dithering, allowing 4 modes )
	}
	Mmode-no-dithering is-mode ?{
		Mmode-no-dithering #01 set-mode
		!display-init
	}

	Mmode-no-dithering #00 set-mode
	!display-init


@on-dpad-up ( -> )
	Mmode-streaming is-mode ?end
	.current-palette LDZ2 
	#000c ADD2
	DUP2 ;palettes/kwgb NEQ2 ?{
		;ext-uxn38-fg-color/v LDA #01 NEQ ?{
			[ LIT2 01 -mode-uxn38 ] STZ
			.current-palette STZ2
			prepare-palette-uxn38
			!display-init
		}
	}
	[ LIT2 00 -mode-uxn38 ] STZ
	DUP2 ;palettes/detected-from-img LTH2 ?{
		POP2 ;palettes
	}
	.current-palette STZ2
	prepare-palette-builtin
	!display-init


@on-dpad-down ( -> )
	Mmode-streaming is-mode ?end
	.current-palette LDZ2
	DUP2 ;palettes GTH2 ?{
		POP2 ;palettes/detected-from-img
	}
	#000c SUB2
	DUP2 ;palettes/kwgb NEQ2 ?{
		;ext-uxn38-fg-color/v LDA #01 NEQ ?{
			[ LIT2 01 -mode-uxn38 ] STZ
			.current-palette STZ2
			prepare-palette-uxn38
			!display-init
		}
	}
	[ LIT2 00 -mode-uxn38 ] STZ
	.current-palette STZ2
	prepare-palette-builtin
	!display-init


@is-mode ( mode -: bool )
	.current-mode LDZ AND #00 NEQ
	JMP2r


@set-mode ( mode value -- bool )
	?{ .current-mode LDZ EOR .current-mode STZ JMP2r }
	.current-mode LDZ ORA .current-mode STZ
	JMP2r




( image formats )


@detect-magic ( {buffer}* -- )
	DUP2 ;&farbfeld str-starts-with ?{
		!&try-qoi
	}
	;&farbfeld print-str Mendl
	POP2
	;ff-size set-on-bytes-received
	#0008 set-bytes-expected
	JMP2r

	[ &farbfeld "farbfeld 00 ]
	[ &qoif "qoif 00 ]

	&try-qoi
	DUP2 ;&qoif str-starts-with ?{
		!bad-file
	}
	;&qoif print-str Mendl
	!qoi-header1


@ff-size ( {buffer}* -- )
	          LDA2k Mnon-zero2 ?too-large
	INC2 INC2 LDA2k ( width ) SWP2 
	INC2 INC2 LDA2k Mnon-zero2 ?too-large
	INC2 INC2 LDA2 ( height )

	handle-image-size

	;ff-next-pixel set-on-bytes-received
	#0008 set-bytes-expected
	JMP2r

	
( farbfeld uses 16-bit depth, not alpha-premultiplied ) 
( we don't load the lower 8 bits )
@ff-next-pixel ( {buffer}* -- )
	STH2k #0006 ADD2 LDA ( alpha )
	( 255 INC becomes 0, so lambda isn't skipped -> opaque )
	INCk ?{
		( alpha is zero )
		POP
		LDAkr STHr     ( r )
		#0002 Msk+ LDA ( g )
		#0004 Ms+  LDA ( b )
		!&result
	}
	#00 SWP
	DUP2 #00 LDAkr STHr     MUL2 POP (    00 aa ar )
	ROT ROT
	DUP2 #00 #0002 Msk+ LDA MUL2 POP ( ar 00 aa ag )
	ROT ROT
	     #00 #0004 Ms+  LDA MUL2 POP ( ar ag ab )
	&result
	srgb-to-linear
	[ LIT2 &on-pixel-received $2 ] JMP2


@alpha-multiply ( r g b a -- r*a g*a b*a )
	INCk ?{ POP JMP2r } ( don't multiply if opaque )
	( r g b a )
	STHk #00 ROT #00 STHr MUL2 POP STH 
	( r g a | b*a )
	STHk #00 ROT #00 STHr MUL2 POP STH 
	( r a | b*a g*a )
	STH  #00 SWP #00 STHr MUL2 POP
	STH2r SWP2r
	JMP2r


@qoi-header1 ( {buffer}* -- )
	#0004 ADD2
	( width )
	DUP2 LDA2 Mnon-zero2 ?too-large
	INC2 INC2 LDA2 ;&w STA2

	;qoi-header2 set-on-bytes-received
	#0006 set-bytes-expected
	JMP2r
&w $2


@qoi-header2 ( {buffer}* -- )
	( height )
	LDA2k Mnon-zero2 ?too-large
	INC2 INC2 LDA2k
	( width, again )
	;qoi-header1/w LDA2

	SWP2 handle-image-size

	INC2 INC2 INC2 ( ignore channel count )
	LDA 
	LIT "S Mdebug-byte Mendl
	;qoi-is-linear STA
	
	;qoi-last
	&loop
		#0000 OVR2 STA2
		INC2 INC2
		DUP2 ;qoi-index/end LTH2
	?&loop
	POP2
	#ff ;qoi-last/a STA

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r


@qoi-last  [ &r $1  &g $1  &b $1  &a $1  ]
@qoi-index [ &r $40 &g $40 &b $40 &a $40 ] &end $2

%Mqoi-stlast {
	STH2 DUP2 ;qoi-last/r STA2 
	STH2r DUP2 ;qoi-last/b STA2
}


@qoi-stindex ( r g b a -- r g b a )
	SWP2k
	( r g b a b a r g )
	    #05 MUL     ( 5g )
	SWP #03 MUL ADD ( 3r )
	SWP #0b MUL ADD ( 11a )
	SWP #07 MUL ADD ( 7b )
	#3f AND LITr 00 STH
	SWP2k
	;qoi-index/g Msk+ STA
	;qoi-index/r Msk+ STA
	;qoi-index/a Msk+ STA
	;qoi-index/b Ms+  STA
	JMP2r


@qoi-chunk ( {buffer}* -- )
	LDA
	( QOI_OP_RGB )
	#fe NEQk ?{
		POP2
		;qoi-chunk-rgb set-on-bytes-received
		#0003 set-bytes-expected
		JMP2r
	}
	POP
	( QOI_OP_RGBA )
	#ff NEQk ?{
		POP2
		;qoi-chunk-rgba set-on-bytes-received
		#0004 set-bytes-expected
		JMP2r
	}
	POP
	( QOI_OP_INDEX )
	DUP #06 SFT ?{
		( 7 6 5 4 3 2 1 0 )
		( 0 0|   index    )
		#00 SWP #3f AND STH2
		;qoi-index/r Msk+ LDA
		;qoi-index/g Msk+ LDA
		;qoi-index/b Msk+ LDA
		;qoi-index/a Ms+ LDA
		Mqoi-stlast
		alpha-multiply
		!qoi-on-pixel-received
	}
	( QOI_OP_DIFF )
	DUP #06 SFT #01 NEQ ?{
		( 7 6 5 4 3 2 1 0 )
		( 0 1| dr| dg| db )
		DUP #04 SFT #03 AND ;qoi-last/r LDA ADD #02 SUB 
		OVR #02 SFT #03 AND ;qoi-last/g LDA ADD #02 SUB 
		ROT         #03 AND ;qoi-last/b LDA ADD #02 SUB 
			            ;qoi-last/a LDA
		Mqoi-stlast
		qoi-stindex
		alpha-multiply
		!qoi-on-pixel-received
	}
	( QOI_OP_LUMA )
	DUP #06 SFT #02 NEQ ?{
		( 7 6 5 4 3 2 1 0 | 7 6 5 4 3 2 1 0 )
		( 1 0| diff green |  dr-rg | db-dg  )
		#3f AND ;qoi-chunk-luma/dg STA
		;qoi-chunk-luma set-on-bytes-received
		#0001 set-bytes-expected
		JMP2r
	}
	( QOI_OP_RUN )
	( 7 6 5 4 3 2 1 0 )
	( 1 1| run length )
	#3f AND INC
	;qoi-last/r LDA
	;qoi-last/g LDA
	;qoi-last/b LDA
	;qoi-last/a LDA
	alpha-multiply
	ROT STH STH2
	#00
	( wst: length count | rst: r g b )
	&run-loop
		ROTkr STHr STH2r
		( wst: length count r g b | rst: r g b )
		qoi-on-pixel-received
		INC
		NEQk 
	?&run-loop
	POP2 POP2r POPr
	JMP2r


@qoi-chunk-rgb ( {buffer}* -- )
	             LDAk
	ROT ROT INC2 LDAk 
	ROT ROT INC2 LDA
	;qoi-last/a LDA

	qoi-stindex
	Mqoi-stlast

	alpha-multiply
	qoi-on-pixel-received

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r


@qoi-chunk-rgba ( {buffer}* -- )
	             LDAk 
	ROT ROT INC2 LDAk 
	ROT ROT INC2 LDAk
	ROT ROT INC2 LDA

	qoi-stindex
	Mqoi-stlast

	alpha-multiply
	qoi-on-pixel-received

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r


( 7 6 5 4 3 2 1 0 | 7 6 5 4 3 2 1 0 )
( 0 1| diff green |  dr-rg | db-dg  )
@qoi-chunk-luma ( {buffer}* -- )
	LDA 
	DUP #04 SFT 
	[ ;&dg LDA ] ADD #28 SUB
	;qoi-last/r LDA ADD
	
	[ ;&dg LDA ] #20 SUB
	;qoi-last/g LDA ADD

	ROT #0f AND
	[ ;&dg LDA ] ADD #28 SUB
	;qoi-last/b LDA ADD

	;qoi-last/a LDA

	qoi-stindex
	Mqoi-stlast

	alpha-multiply
	qoi-on-pixel-received

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r
&dg $1


@qoi-on-pixel-received ( r g b -- )
	[ ,qoi-is-linear LDR ] ?{
		srgb-to-linear
	}
	[ LIT2 &routine $2 ] JMP2


@qoi-is-linear $1


( misc. )


@handle-image-size ( w* h* -- )
	;str/height print-str DUP2 Mprint-short Mendl

	DUP2 .Screen/height DEO2 .img-h STZ2

	;str/width print-str DUP2 Mprint-short Mendl

	DUP2 .Screen/width DEO2 .img-w STZ2
	JMP2r


@prepare-palette-colors-builtin ( -- )
	.current-palette LDZ2 
	          LDA2k .color0/g STZ .color0/r STZ
	INC2 INC2 LDA2k .color1/r STZ .color0/b STZ
	INC2 INC2 LDA2k .color1/b STZ .color1/g STZ
	INC2 INC2 LDA2k .color2/g STZ .color2/r STZ
	INC2 INC2 LDA2k .color3/r STZ .color2/b STZ
	INC2 INC2 LDA2  .color3/b STZ .color3/g STZ
	JMP2r


@prepare-palette-builtin ( -- )
	prepare-palette-colors-builtin
	( fallthrough )


@prepare-palette-screen ( -- )
	{ 20 "0123 0a 00 } STH2r print-str
	.color0/r LDZ linear-to-srgb-single #f0 AND
	.color1/r LDZ linear-to-srgb-single #04 SFT ORA
	.color2/r LDZ linear-to-srgb-single #f0 AND
	.color3/r LDZ linear-to-srgb-single #04 SFT ORA
	LIT "R Mdebug-short Mendl
	.System/r DEO2

	.color0/g LDZ linear-to-srgb-single #f0 AND
	.color1/g LDZ linear-to-srgb-single #04 SFT ORA
	.color2/g LDZ linear-to-srgb-single #f0 AND
	.color3/g LDZ linear-to-srgb-single #04 SFT ORA
	LIT "G Mdebug-short Mendl
	.System/g DEO2

	.color0/b LDZ linear-to-srgb-single #f0 AND
	.color1/b LDZ linear-to-srgb-single #04 SFT ORA
	.color2/b LDZ linear-to-srgb-single #f0 AND
	.color3/b LDZ linear-to-srgb-single #04 SFT ORA
	LIT "B Mdebug-short Mendl
	.System/b DEO2

	( get minimum and maximum colors )
	.color3/r LDZ [ LITr -color2/r ]
	&get-min-r ( min-r | {zaddr} )
		STHkr LDZ
		LTHk ?{ SWP } POP
		STHkr .color0/r EQU ?&get-min-r-end
		[ LITr 03 ] SUBr
		!&get-min-r
	&get-min-r-end
	POPr
	LIT "r Mdebug-byte Mendl
	.color-min/r STZ

	.color3/g LDZ [ LITr -color2/g ]
	&get-min-g ( min-g | {zaddr} )
		STHkr LDZ
		LTHk ?{ SWP } POP
		STHkr .color0/g EQU ?&get-min-g-end
		[ LITr 03 ] SUBr
		!&get-min-g
	&get-min-g-end
	POPr
	LIT "g Mdebug-byte Mendl
	.color-min/g STZ

	.color3/b LDZ [ LITr -color2/b ]
	&get-min-b ( min-b | {zaddr} )
		STHkr LDZ
		LTHk ?{ SWP } POP
		STHkr .color0/b EQU ?&get-min-b-end
		[ LITr 03 ] SUBr
		!&get-min-b
	&get-min-b-end
	POPr
	LIT "b Mdebug-byte Mendl
	.color-min/b STZ

	.color3/r LDZ [ LITr -color2/r ]
	&get-max-r ( max-r | {zaddr} )
		STHkr LDZ
		GTHk ?{ SWP } POP
		STHkr .color0/r EQU ?&get-max-r-end
		[ LITr 03 ] SUBr
		!&get-max-r
	&get-max-r-end
	POPr
	LIT "R Mdebug-byte Mendl
	.color-max/r STZ

	.color3/g LDZ [ LITr -color2/g ]
	&get-max-g ( max-g | {zaddr} )
		STHkr LDZ
		GTHk ?{ SWP } POP
		STHkr .color0/g EQU ?&get-max-g-end
		[ LITr 03 ] SUBr
		!&get-max-g
	&get-max-g-end
	POPr
	LIT "G Mdebug-byte Mendl
	.color-max/g STZ

	.color3/b LDZ [ LITr -color2/b ]
	&get-max-b ( max-b | {zaddr} )
		STHkr LDZ
		GTHk ?{ SWP } POP
		STHkr .color0/b EQU ?&get-max-b-end
		[ LITr 03 ] SUBr
		!&get-max-b
	&get-max-b-end
	POPr
	LIT "B Mdebug-byte Mendl
	.color-max/b STZ

	JMP2r

@prepare-palette-uxn38 ( -- )
	;ext-uxn38-fg-color .System/expansion DEO2
	;str/uxn38-color-ext print-str
	prepare-palette-colors-builtin

	( color4 = magenta(unused): #ff00ff )
	LIT2 ff
	     00 .color4/r STZ2 
	LIT2 ff
	( color5 = red: #ff0000 )
	     ff .color4/b STZ2 
	LIT2 00
	     00 .color5/g STZ2
	( color6 = cyan: #00ffff )
	LIT2 00
	     ff .color6/r STZ2
	LIT2 ff
	( color7 = yellow: #ffff00 )
	     ff .color6/b STZ2
	LIT2 ff
	     00 .color7/g STZ2
	( color-min: #000000 )
	LIT2 00
	     00 .color-min/r STZ2
	LIT2 00
	( color-max: #ffffff )
	     ff .color-min/b STZ2
	LIT2 ff
	     ff .color-max/g STZ2

	JMP2r


( 6-bit linear RGB is used for dithering )
( 7-bit linear RGB is used for color partitions )
@rgb-sft ( r g b sft -- rs gs bs )
	SFTk STH NIP ( r g sft | bs )
	SFTk STH NIP ( r sft | bs gs )
	SFT          ( rs | bs gs )
	STHr STHr
	JMP2r




( image processing )


( 8-bit sRGB triplet to 8-bit linear RGB triplet )
@srgb-to-linear ( sr sg sb -- r g b )
	ROT #00 SWP ;&lut ADD2 LDA
	ROT #00 SWP ;&lut ADD2 LDA
	ROT #00 SWP ;&lut ADD2 LDA
	JMP2r	
&lut [
	00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 01 
	01 01 02 02 02 02 02 02 02 02 03 03 03 03 03 03 
	04 04 04 04 04 05 05 05 05 06 06 06 06 07 07 07 
	08 08 08 08 09 09 09 0a 0a 0a 0b 0b 0c 0c 0c 0d 
	0d 0d 0e 0e 0f 0f 10 10 11 11 11 12 12 13 13 14 
	14 15 16 16 17 17 18 18 19 19 1a 1b 1b 1c 1d 1d 
	1e 1e 1f 20 20 21 22 23 23 24 25 25 26 27 28 29 
	29 2a 2b 2c 2d 2d 2e 2f 30 31 32 33 33 34 35 36 
	37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 
	47 48 49 4a 4c 4d 4e 4f 50 51 52 54 55 56 57 58 
	5a 5b 5c 5d 5f 60 61 63 64 65 67 68 69 6b 6c 6d 
	6f 70 72 73 74 76 77 79 7a 7c 7d 7f 80 82 83 85 
	86 88 8a 8b 8d 8e 90 92 93 95 97 98 9a 9c 9d 9f 
	a1 a3 a4 a6 a8 aa ab ad af b1 b3 b5 b7 b8 ba bc 
	be c0 c2 c4 c6 c8 ca cc ce d0 d2 d4 d6 d8 da dc 
	de e0 e2 e5 e7 e9 eb ed ef f2 f4 f6 f8 fa fd ff 
]

( single 8-bit linear RGB value to 8-bit sRGB value )
@linear-to-srgb-single ( scolor -- color )
	#00 SWP ;&lut ADD2 LDA
	JMP2r	
&lut [
	00 0d 16 1c 22 26 2a 2e 32 35 38 3b 3d 40 42 45 
	47 49 4b 4d 4f 51 53 55 56 58 5a 5c 5d 5f 60 62 
	63 65 66 68 69 6a 6c 6d 6e 70 71 72 73 75 76 77 
	78 79 7a 7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 
	89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 94 95 96 97 
	98 99 9a 9b 9b 9c 9d 9e 9f 9f a0 a1 a2 a3 a3 a4 
	a5 a6 a7 a7 a8 a9 aa aa ab ac ad ad ae af af b0 
	b1 b2 b2 b3 b4 b4 b5 b6 b6 b7 b8 b9 b9 ba bb bb 
	bc bd bd be be bf c0 c0 c1 c2 c2 c3 c4 c4 c5 c5 
	c6 c7 c7 c8 c8 c9 ca ca cb cb cc cd cd ce ce cf 
	d0 d0 d1 d1 d2 d2 d3 d4 d4 d5 d5 d6 d6 d7 d7 d8 
	d8 d9 da da db db dc dc dd dd de de df df e0 e0 
	e1 e2 e2 e3 e3 e4 e4 e5 e5 e6 e6 e7 e7 e8 e8 e9 
	e9 ea ea eb eb ec ec ed ed ee ee ee ef ef f0 f0 
	f1 f1 f2 f2 f3 f3 f4 f4 f5 f5 f6 f6 f6 f7 f7 f8 
	f8 f9 f9 fa fa fb fb fb fc fc fd fd fe fe ff ff
]


( partitioning color space, via median cut algorithm )

( see bottom of file for partition structure )
%Mpart-sort-buffer-size { #0200 } 
%Mpart-sort-buffers-size { #0600 } 
%Mpart-size { #060a } 
%Mpart-max-color { #7f }
%Mpart-color-sft { #01 }
%Mpart-color-sft-ret { #10 }


@part-debug ( part -- )
	( POP JMP2r )

	#00 OVR Mpart-size MUL2 STH2
	( { "part 20 00 } STH2r print-str DUP print-byte Mcout )
	LIT "R Mcout ;part/r-beg Msk+ LDA2 
	SWP print-byte LIT "- Mcout print-byte LIT ", Mcout
	LIT "G Mcout ;part/g-beg Msk+ LDA2
	SWP print-byte LIT "- Mcout print-byte LIT ", Mcout
	LIT "B Mcout ;part/b-beg Msk+ LDA2
	SWP print-byte LIT "- Mcout print-byte Mendl

	.part-split-step LDZ INC LTH ?{ POP2r JMP2r }

	LIT "C Mcout ;part/count Msk+ 
	LDA2k Mprint-short INC2 INC2 LDA2 Mprint-short Mendl

	#0000 
	LIT "S Mcout LIT "R Mcout Mendl
	&loopr
		DUP2 #02 SFT2 NIP
		print-byte LIT "| Mcout
		DUP2 ;part/r-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/r-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 
		DUP #30 SFT ?{ Mendl !&end-print-r }
		#20 Mcout
		&end-print-r
		Mpart-sort-buffer-size NEQ2
	?&loopr

	POP2 #0000 
	LIT "S Mcout LIT "G Mcout Mendl
	&loopg
		DUP2 #02 SFT2 NIP
		print-byte LIT "| Mcout
		DUP2 ;part/g-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/g-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 
		DUP #30 SFT ?{ Mendl !&end-print-g }
		#20 Mcout
		&end-print-g
		Mpart-sort-buffer-size NEQ2
	?&loopg

	#0000 
	LIT "S Mcout LIT "B Mcout Mendl
	&loopb
		DUP2 #02 SFT2 NIP
		print-byte LIT "| Mcout
		DUP2 ;part/b-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/b-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 
		DUP #30 SFT ?{ Mendl !&end-print-b }
		#20 Mcout
		&end-print-b
		Mpart-sort-buffer-size NEQ2
	?&loopb
	POP2
	Mendl POP2r
	JMP2r


@part-init ( part -- )
	#00 SWP Mpart-size MUL2 STH2
	#0000 ;part/count Msk+ STA2k
	INC2 INC2 STA2
	#0000 
	&loop
		#0000 OVR2 ;part/r-sort ADD2 Msk+ STA2
		INC2 INC2 DUP2 Mpart-sort-buffers-size NEQ2
	?&loop
	POP2 POP2r
	JMP2r


@part-add-pixel ( rs gs bs part -- )
	#00 SWP Mpart-size MUL2 STH2
	#00 SWP #20 SFT2 ;part/b-sort Msk+ ADD2 inc32-addr
	#00 SWP #20 SFT2 ;part/g-sort Msk+ ADD2 inc32-addr
	#00 SWP #20 SFT2 ;part/r-sort Msk+ ADD2 inc32-addr
	;part/count Ms+ 
	!inc32-addr


( get color variation within partition )
@part-get-max-var ( part -- max-var-chan max-var )
	#00 SWP Mpart-size MUL2 
	STH2
	;part/count Msk+ Mload32
	( does partition have enough pixels to bother splitting? )
	.img-w LDZ2 .img-h LDZ2 mul16 #05 rshift32
	gteq32 ?{ ;str/part-too-small print-str POP2r #0000 JMP2r }


	( order of preference:
	  if green has equal variation to red or blue, prefer green
	  if red has equal variation to blue, prefer red )
	( we will ignore values less than 1/256th of max value )
	%Mpart-var-filter { #08 }

	LIT "G Mcout 

	( find max value )
	#0000 DUP2 [ ,&g-max-h STR2 ] [ ,&g-max-l STR2 ]
	;part/g-beg Msk+ LDA
	&find-g-max
		#00 OVR #20 SFT2 ;part/g-sort ADD2 Msk+ Mload32 
		OVR2 OVR2
		[ ,&g-max-h LDR2 ] [ ,&g-max-l LDR2 ]
		( index valh* vall* valh* vall* maxh* maxl* )
		lt32 ?{ [ ,&g-max-l STR2 ] [ ,&g-max-h STR2 ] !&g-max }
		POP2 POP2
		&g-max
		INC
		DUP ;part/g-end Msk+ LDA NEQ ?{ !&found-g-max }
	!&find-g-max
	[ &g-max-h $2 &g-max-l $2 ]
	&found-g-max
	POP
	[ ,&g-max-h LDR2 ] [ ,&g-max-l LDR2 ] 
	LIT "M Mdebug32
	Mpart-var-filter rshift32 
	LIT "> Mdebug32
	[ ,&g-max-l STR2 ] [ ,&g-max-h STR2 ]

	( find index of first non-zero element )
	;part/g-beg Msk+ LDA
	&find-g-beg
		#00 OVR #20 SFT2 ;part/g-sort ADD2 Msk+ Mload32 
		[ ,&g-max-h LDR2 ] [ ,&g-max-l LDR2 ]
		gteq32 ?&found-g-beg
		INC
	!&find-g-beg
	&found-g-beg
	LIT "B Mdebug-byte

	( find index of last non-zero element )
	;part/g-end Msk+ LDA #01 SUB
	&find-g-end
		#00 OVR #20 SFT2 ;part/g-sort ADD2 Msk+ Mload32 
		;&g-max-h LDA2 ;&g-max-l LDA2
		gteq32 ?&found-g-end
		#01 SUB
	!&find-g-end
	&found-g-end
	LIT "E Mdebug-byte
	SWP SUB
	LIT "V Mdebug-byte Mendl


	LIT "R Mcout 

	( find max value )
	#0000 DUP2 [ ,&r-max-h STR2 ] [ ,&r-max-l STR2 ]
	;part/r-beg Msk+ LDA
	&find-r-max
		#00 OVR #20 SFT2 ;part/r-sort ADD2 Msk+ Mload32 
		OVR2 OVR2
		[ ,&r-max-h LDR2 ] [ ,&r-max-l LDR2 ]
		( index valh* vall* valh* vall* maxh* maxl* )
		lt32 ?{ [ ,&r-max-l STR2 ] [ ,&r-max-h STR2 ] !&r-max }
		POP2 POP2
		&r-max
		INC
		DUP ;part/r-end Msk+ LDA NEQ ?{ !&found-r-max }
	!&find-r-max
	[ &r-max-h $2 &r-max-l $2 ]
	&found-r-max
	POP
	[ ,&r-max-h LDR2 ] [ ,&r-max-l LDR2 ] 
	LIT "M Mdebug32
	Mpart-var-filter rshift32 
	LIT "> Mdebug32
	[ ,&r-max-l STR2 ] [ ,&r-max-h STR2 ]

	( find index of first non-zero element )
	;part/r-beg Msk+ LDA
	&find-r-beg
		#00 OVR #20 SFT2 ;part/r-sort ADD2 Msk+ Mload32 
		[ ,&r-max-h LDR2 ] [ ,&r-max-l LDR2 ]
		gteq32 ?&found-r-beg
		INC
	!&find-r-beg
	&found-r-beg
	LIT "B Mdebug-byte

	( find index of last non-zero element )
	;part/r-end Msk+ LDA #01 SUB
	&find-r-end
		#00 OVR #20 SFT2 ;part/r-sort ADD2 Msk+ Mload32 
		;&r-max-h LDA2 ;&r-max-l LDA2
		gteq32 ?&found-r-end
		#01 SUB
	!&find-r-end
	&found-r-end
	LIT "E Mdebug-byte
	SWP SUB
	LIT "V Mdebug-byte Mendl


	LIT "B Mcout 

	( find max value )
	#0000 DUP2 [ ,&b-max-h STR2 ] [ ,&b-max-l STR2 ]
	;part/b-beg Msk+ LDA
	&find-b-max
		#00 OVR #20 SFT2 ;part/b-sort ADD2 Msk+ Mload32 
		OVR2 OVR2
		[ ,&b-max-h LDR2 ] [ ,&b-max-l LDR2 ]
		( index valh* vall* valh* vall* maxh* maxl* )
		lt32 ?{ [ ,&b-max-l STR2 ] [ ,&b-max-h STR2 ] !&b-max }
		POP2 POP2
		&b-max
		INC
		DUP ;part/b-end Msk+ LDA NEQ ?{ !&found-b-max }
	!&find-b-max
	[ &b-max-h $2 &b-max-l $2 ]
	&found-b-max
	POP
	[ ,&b-max-h LDR2 ] [ ,&b-max-l LDR2 ] 
	LIT "M Mdebug32
	Mpart-var-filter rshift32 
	LIT "> Mdebug32
	[ ,&b-max-l STR2 ] [ ,&b-max-h STR2 ]

	( find index of first non-zero element )
	;part/b-beg Msk+ LDA
	&find-b-beg
		#00 OVR #20 SFT2 ;part/b-sort ADD2 Msk+ Mload32 
		[ ,&b-max-h LDR2 ] [ ,&b-max-l LDR2 ]
		gteq32 ?&found-b-beg
		INC
	!&find-b-beg
	&found-b-beg
	LIT "B Mdebug-byte

	( find index of last non-zero element )
	;part/b-end Msk+ LDA #01 SUB
	&find-b-end
		#00 OVR #20 SFT2 ;part/b-sort ADD2 Msk+ Mload32 
		;&b-max-h LDA2 ;&b-max-l LDA2
		gteq32 ?&found-b-end
		#01 SUB
	!&find-b-end
	&found-b-end
	LIT "E Mdebug-byte
	SWP SUB
	LIT "V Mdebug-byte Mendl
	Mendl


	POP2r

	Mb STH
	( wst: gvar rvar max-var | rst: max-var-chan )
	LTHk ?{ POPr Mr STH SWP } NIP 
	( wst: gvar max-var | rst: max-var-chan )
	LTHk ?{ POPr Mg STH SWP } NIP 
	
	STHr SWP
	JMP2r


@part-get-median ( {sorted}* {count}* -- median )
	Mload32 
	OVR2 OVR2 [ ,&countl STR2 ] [ ,&counth STR2 ]
	#01 shift32-0 [ ,&halfl STR2 ] [ ,&halfh STR2 ]
	DUP2 #0000 DUP2 ROT2

	( sum the sorted pixel values )
	( iterate until sum is half of all values )
	&loop ( buffer* sumh* suml* ptr* )
		STH2k Mload32
		add32
		OVR2 OVR2
		[ LIT2 &halfh $2 ] [ LIT2 &halfl $2 ] lt32 ?{ 
			( reached half -> found median )

			( now decide which partition to insert into )
			( if sum - current_val > count - sum
			  then there are more items before current index 
			  than after it )
			( we try to keep partitions balanced )

			( buffer* sumh* suml* | ptr* )
			STH2 STH2
			[ LIT2 &counth $2 ] [ LIT2 &countl $2 ]
			STH2kr SWP2r STH2kr
			( buffer* counth* countl* sumh* suml* | ptr* sumh* suml* )
			sub32
			SWP2r STH2r STH2r 
			STH2kr Mload32
			sub32
			lt32 ?{
				( increment ptr*, thus add current value 
				  to first partition, which is smaller )
				LIT "! Mcout
				LIT "! Mcout
				LIT "! Mcout
				LIT "! Mcout
				LIT "! Mcout
				[ LIT2r 0004 ] ADD2r
			}
			STH2r
			SWP2 SUB2
			#02 SFT2 NIP
			JMP2r
		}
		STH2r #0004 ADD2
	!&loop


@get-partition-optimize ( -- )
	#00 ;get-partition/check0 STA

	.part-split-step LDZ
	DUP #00 EQU ?{
		#01 ;get-partition/check0 STA

		;part/r-beg LDA ;get-partition/part0-r-beg STA
		;part/g-beg LDA ;get-partition/part0-g-beg STA
		;part/b-beg LDA ;get-partition/part0-b-beg STA
		;part/r-end LDA ;get-partition/part0-r-end STA
		;part/g-end LDA ;get-partition/part0-g-end STA
		;part/b-end LDA ;get-partition/part0-b-end STA

		#00 ;get-partition/check1 STA
	}
	DUP #02 LTH ?{
		#01 ;get-partition/check1 STA

		;part1/r-beg LDA ;get-partition/part1-r-beg STA
		;part1/g-beg LDA ;get-partition/part1-g-beg STA
		;part1/b-beg LDA ;get-partition/part1-b-beg STA
		;part1/r-end LDA ;get-partition/part1-r-end STA
		;part1/g-end LDA ;get-partition/part1-g-end STA
		;part1/b-end LDA ;get-partition/part1-b-end STA

		#00 ;get-partition/check2 STA
	}
	#03 LTH ?{ 
		#01 ;get-partition/check2 STA

		;part2/r-beg LDA ;get-partition/part2-r-beg STA
		;part2/g-beg LDA ;get-partition/part2-g-beg STA
		;part2/b-beg LDA ;get-partition/part2-b-beg STA
		;part2/r-end LDA ;get-partition/part2-r-end STA
		;part2/g-end LDA ;get-partition/part2-g-end STA
		;part2/b-end LDA ;get-partition/part2-b-end STA
	}
	JMP2r


@get-partition ( r g b -- r g b part )
	[ LIT &check0 $1 ] ?{ #00 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part0-r-beg $1 ] LTH ?{ !&r0 } POP2 POP !&part1
	&r0 [ LIT &part0-r-end $1 ] LTH ?{ POP2 !&part1 }

	DUP [ LIT &part0-b-beg $1 ] LTH ?{ !&b0 } POP2 !&part1
	&b0 [ LIT &part0-b-end $1 ] LTH ?{ POP !&part1 }

	DUP [ LIT &part0-g-beg $1 ] LTH ?{ !&g0 } POP !&part1
	&g0 [ LIT &part0-g-end $1 ] LTH ?{ !&part1 }
	#00 JMP2r

	&part1
	[ LIT &check1 $1 ] ?{ #01 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part1-r-beg $1 ] LTH ?{ !&r1 } POP2 POP !&part2
	&r1 [ LIT &part1-r-end $1 ] LTH ?{ POP2 !&part2 }

	DUP [ LIT &part1-b-beg $1 ] LTH ?{ !&b1 } POP2 !&part2
	&b1 [ LIT &part1-b-end $1 ] LTH ?{ POP !&part2 }

	DUP [ LIT &part1-g-beg $1 ] LTH ?{ !&g1 } POP !&part2
	&g1 [ LIT &part1-g-end $1 ] LTH ?{ !&part2 }
	#01 JMP2r

	&part2
	[ LIT &check2 $1 ] ?{ #02 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part2-r-beg $1 ] LTH ?{ !&r2 } POP2 POP !&part3
	&r2 [ LIT &part2-r-end $1 ] LTH ?{ POP2 !&part3 }

	DUP [ LIT &part2-b-beg $1 ] LTH ?{ !&b2 } POP2 !&part3
	&b2 [ LIT &part2-b-end $1 ] LTH ?{ POP !&part3 }

	DUP [ LIT &part2-g-beg $1 ] LTH ?{ !&g2 } POP !&part3
	&g2 [ LIT &part2-g-end $1 ] LTH ?{ !&part3 }
	#02 JMP2r

	&part3
	#03
	JMP2r


@palette-split-init ( -> )
	get-partition-optimize

	#00 part-init
	.part-split-step LDZ DUP ?{
		Mpart-max-color INC ;part/r-end STA
		Mpart-max-color INC ;part/g-end STA
		Mpart-max-color INC ;part/b-end STA
	}
	DUP #00 EQU ?{
		#01 part-init 
		#02 LTH ?{
			#02 part-init
		}
	}

	;palette-split set-on-pixel-received
	;palette-split-end set-on-file-end
	;read-file .Screen/vector DEO2
	BRK


@palette-split ( r8 g8 b8 -- )
	Mpart-color-sft rgb-sft
	get-partition
	DUP ?{
		!part-add-pixel ( 0 )
	}
	#01 GTHk ?{
		POP
		!part-add-pixel ( 1 )
	}
	POP
	#02 NEQk ?{
		POP
		!part-add-pixel ( 2 )
	} 
	POP
	!part-add-pixel


@palette-split-end ( -> )
	Mendl Mendl Mendl
	#00 part-debug
	#01 part-debug
	#02 part-debug
	#03 part-debug

	( find partition with largest color variation )

	#0000 part-get-max-var
	( max-var-part max-var-chan max-var )
	.part-split-step LDZ ?{ !&found-max-var }
	#01 part-get-max-var 
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #01 STH2r !&part2-var
	}
	NIP NIP
	&part2-var
	.part-split-step LDZ #01 GTH ?{ !&found-max-var }
	#02 part-get-max-var 
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #02 STH2r !&part3-var
	}
	NIP NIP
	&part3-var
	.part-split-step LDZ #02 GTH ?{ !&found-max-var }
	#03 part-get-max-var 
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #03 STH2r !&found-max-var
	}
	NIP NIP
	&found-max-var
	POP

	( split partition )

	DUP Mr NEQ ?{
		POP
		.part-split-step LDZ INC
		#00 SWP Mpart-size MUL2 STH2
		LIT "~ Mdebug-byte
		#00 SWP Mpart-size MUL2 STH2
		( rst: dest-part-offset* src-part-offset* )

		;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r
		;part/r-sort Msk+ ;part/count Msk+ part-get-median DUP 
		LIT "r Mdebug-byte Mendl
		;part/r-end Msk+ STA SWP2r ;part/r-beg Msk+ STA SWP2r

		;part/g-beg Msk+ LDA SWP2r ;part/g-beg Msk+ STA SWP2r
		;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r

		;part/b-beg Msk+ LDA SWP2r ;part/b-beg Msk+ STA SWP2r
		;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
		!&split-done
	}
	DUP Mg NEQ ?{
		POP
		.part-split-step LDZ INC
		#00 SWP Mpart-size MUL2 STH2
		LIT "~ Mdebug-byte
		#00 SWP Mpart-size MUL2 STH2
		( rst: dest-part-offset* src-part-offset* )

		;part/r-beg Msk+ LDA SWP2r ;part/r-beg Msk+ STA SWP2r
		;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r

		;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r
		;part/g-sort Msk+ ;part/count Msk+ part-get-median DUP 
		LIT "g Mdebug-byte Mendl
		;part/g-end Msk+ STA SWP2r ;part/g-beg Msk+ STA SWP2r

		;part/b-beg Msk+ LDA SWP2r ;part/b-beg Msk+ STA SWP2r
		;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
		!&split-done
	}
	POP
	.part-split-step LDZ INC
	#00 SWP Mpart-size MUL2 STH2
	LIT "~ Mdebug-byte
	#00 SWP Mpart-size MUL2 STH2
	( rst: dest-part-offset* src-part-offset* )

	;part/r-beg Msk+ LDA SWP2r ;part/r-beg Msk+ STA SWP2r
	;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r

	;part/g-beg Msk+ LDA SWP2r ;part/g-beg Msk+ STA SWP2r
	;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r

	;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
	;part/b-sort Msk+ ;part/count Msk+ part-get-median DUP 
	LIT "b Mdebug-byte Mendl
	;part/b-end Msk+ STA SWP2r ;part/b-beg Msk+ STA SWP2r

	&split-done
	POP2r POP2r

	.part-split-step LDZ ?{
		[ LIT2 01 -part-split-step ] STZ
		!palette-split-init
	}
	.part-split-step LDZ [ #01 ] NEQ ?{
		[ LIT2 02 -part-split-step ] STZ
		!palette-split-init
	}
	[ LIT2 03 -part-split-step ] STZ
	( fallthrough )


@last-palette-split-init ( -- )
	#00 part-init
	#01 part-init
	#02 part-init
	#03 part-init
	get-partition-optimize

	;palette-split set-on-pixel-received
	;avg-colors set-on-file-end
	;read-file .Screen/vector DEO2
	JMP2r



@avg-color ( {chan}* {n}* -- avg-color )
	STH2 STH2
	#0000 DUP2k
	( sum** index* | {n}* {chan}* )
	&loop
		DUP2 #20 SFT2 Msk+ ( count addr for index )
		SWP2 STH2
		LDA2k SWP2 INC2 INC2 LDA2 ( load 32-bit count )
		#0000 STH2kr mul32 ( multiply by index )
		add32
		STH2r INC2
		DUP2 #00 Mpart-max-color INC NEQ2 ?{
			POP2 POP2r
			( sum** | {n}* )
			STH2r
			LDA2k SWP2 INC2 INC2 LDA2
			div32
			( clear high 24 bits and check they're zero )
			SWP2 #0000 EQU2 ?{ !fail }
			SWP #00 EQU ?{ !fail }
			JMP2r
		}
	!&loop


@avg-colors ( -> )
	#00 part-debug
	#01 part-debug
	#02 part-debug
	#03 part-debug

	;part/r-sort ;part/count avg-color ;&color0r STA
	;part/g-sort ;part/count avg-color ;&color0g STA
	;part/b-sort ;part/count avg-color ;&color0b STA

	;part1/r-sort ;part1/count avg-color ;&color1r STA
	;part1/g-sort ;part1/count avg-color ;&color1g STA
	;part1/b-sort ;part1/count avg-color ;&color1b STA

	;part2/r-sort ;part2/count avg-color ;&color2r STA
	;part2/g-sort ;part2/count avg-color ;&color2g STA
	;part2/b-sort ;part2/count avg-color ;&color2b STA

	;part3/r-sort ;part3/count avg-color ;&color3r STA
	;part3/g-sort ;part3/count avg-color ;&color3g STA
	;part3/b-sort ;part3/count avg-color ;&color3b STA

	prepare-palette-avg
	!display-init
&color0r $1 &color0g $1 &color0b $1
&color1r $1 &color1g $1 &color1b $1
&color2r $1 &color2g $1 &color2b $1
&color3r $1 &color3g $1 &color3b $1


@prepare-palette-avg ( -- )
	;avg-colors/color0r LDA Mpart-color-sft-ret SFT .color0/r STZ
	;avg-colors/color1r LDA Mpart-color-sft-ret SFT .color1/r STZ
	;avg-colors/color2r LDA Mpart-color-sft-ret SFT .color2/r STZ
	;avg-colors/color3r LDA Mpart-color-sft-ret SFT .color3/r STZ

	;avg-colors/color0g LDA Mpart-color-sft-ret SFT .color0/g STZ
	;avg-colors/color1g LDA Mpart-color-sft-ret SFT .color1/g STZ
	;avg-colors/color2g LDA Mpart-color-sft-ret SFT .color2/g STZ
	;avg-colors/color3g LDA Mpart-color-sft-ret SFT .color3/g STZ

	;avg-colors/color0b LDA Mpart-color-sft-ret SFT .color0/b STZ
	;avg-colors/color1b LDA Mpart-color-sft-ret SFT .color1/b STZ
	;avg-colors/color2b LDA Mpart-color-sft-ret SFT .color2/b STZ
	;avg-colors/color3b LDA Mpart-color-sft-ret SFT .color3/b STZ
	!prepare-palette-screen



( displaying )


@display-init ( -> )
	.color0/r LDZ LIT "R Mdebug-byte
	#02 SFT ;pick-color/color0r STA
	.color0/g LDZ LIT "G Mdebug-byte 
	#02 SFT ;pick-color/color0g STA
	.color0/b LDZ LIT "B Mdebug-byte 
	#02 SFT ;pick-color/color0b STA
	Mendl

	.color1/r LDZ LIT "R Mdebug-byte 
	#02 SFT ;pick-color/color1r STA
	.color1/g LDZ LIT "G Mdebug-byte 
	#02 SFT ;pick-color/color1g STA
	.color1/b LDZ LIT "B Mdebug-byte 
	#02 SFT ;pick-color/color1b STA
	Mendl

	.color2/r LDZ LIT "R Mdebug-byte 
	#02 SFT ;pick-color/color2r STA
	.color2/g LDZ LIT "G Mdebug-byte 
	#02 SFT ;pick-color/color2g STA
	.color2/b LDZ LIT "B Mdebug-byte 
	#02 SFT ;pick-color/color2b STA
	Mendl

	.color3/r LDZ LIT "R Mdebug-byte 
	#02 SFT ;pick-color/color3r STA
	.color3/g LDZ LIT "G Mdebug-byte 
	#02 SFT ;pick-color/color3g STA
	.color3/b LDZ LIT "B Mdebug-byte 
	#02 SFT ;pick-color/color3b STA
	Mendl

	Mmode-no-dithering is-mode ?{
		;display-dither set-on-pixel-received

		#0000
		&clear-buf
			#0000 OVR2 ;dither-buffer/r ADD2 STA2
			#0000 OVR2 ;dither-buffer/g ADD2 STA2
			#0000 OVR2 ;dither-buffer/b ADD2 STA2
			INC2 INC2
			DUP2 .img-w LDZ2 LTH2
		?&clear-buf
		POP2
		.color-min/r LDZ2 ( min-r min-g )
		#01 SFT ;display-dither/min-g7 STA
		#01 SFT ;display-dither/min-r7 STA
		.color-min/b LDZ2 ( min-b max-r )
		LIT "M Mcout Mendl
		#01 SFT 
		LIT "R Mdebug-byte Mendl
		;display-dither/max-r7 STA
		#01 SFT ;display-dither/min-b7 STA
		.color-max/g LDZ2 ( max-g max-b )
		OVR #01 SFT LIT "G Mdebug-byte Mendl POP
		#01 SFT 
		LIT "B Mdebug-byte Mendl
		;display-dither/max-b7 STA
		#01 SFT ;display-dither/max-g7 STA

		!&display-func-set
	}
	;display set-on-pixel-received
	&display-func-set

	;done set-on-file-end
	.current-mode LDZ Mmode-streaming AND ?{
		;read-file .Screen/vector DEO2
	}

	[ LIT2 01 -Screen/auto ] DEO
	#0000 .Screen/x DEO2
	#0000 .Screen/y DEO2

	;ext-uxn38-fg-color/v LDA #00 EQU ?{
		( clear fg pixels )
		[ LIT2 c0 -Screen/pixel ] DEO
	}

	.mode-uxn38 LDZ ?{
		.current-palette LDZ2 ;palettes/detected-from-img EQU2 
		Mmode-partition-color-func is-mode AND ?{
			;pick-color ;display/get-color-func STA2
			;pick-color ;display-dither/get-color-func STA2
			BRK
		}
		;get-partition ;display/get-color-func STA2
		;get-partition ;display-dither/get-color-func STA2
		BRK
	}
	;pick-color-uxn38 ;display/get-color-func STA2
	;pick-color-uxn38 ;display-dither/get-color-func STA2
	BRK


@display ( r8 g8 b8 -- )
	#01 rgb-sft
	[ LIT2 &get-color-func $2 ] JSR2
	NIP2 NIP
	!draw-pixel


( sierra lite dithering )
( quantization error is pushed to the next pixel in line, and
  to two pixels on the next line )
(      X  1/2
  1/4 1/4     )
( we use only one line buffer, and overwrite values behind current x )
@display-dither ( r8 g8 b8 :- )
	[ LITr -Screen/x ] DEI2r

	ROT #01 SFT
	;dither-buffer/r STH2kr ADD2 LDA
	[ LIT2 &min-r7 $1 &max-r7 $1 ] 8+8s-clamp

	( g8 b8 r7-cor | x* )
	ROT #01 SFT
	;dither-buffer/g STH2kr ADD2 LDA 
	[ LIT2 &min-g7 $1 &max-g7 $1 ] 8+8s-clamp

	( b8 r7-cor g7-cor | x* )
	ROT #01 SFT
	;dither-buffer/b STH2kr ADD2 LDA
	[ LIT2 &min-b7 $1 &max-b7 $1 ] 8+8s-clamp

	( r7-cor g7-cor b7-cor | x* )
	[ LIT2 &get-color-func $2 ] JSR2

	( r7-cor g7-cor b7-cor col | x* )
	OVR #01 SFT
	OVR #03 MUL .color0/b ADD LDZ #02 SFT ( ... b6-cor b6-sel | x* )
	SUB 
	DUP2r [ LIT2r =dither-buffer/b ] ADD2r
	( ... b7-delta-half | x* addr* )
	STH2kr INC2 LDA OVR ADD STH2kr INC2       STA  ( next, add 1/2 )
	                half8s  STH2kr            STAk ( curr, set 1/4 )
	#0001 SUB2  LDA ADD     STH2r  #0001 SUB2 STA  ( prev, add 1/4 )

	NIP ( r7-cor g7-cor col | x* )
	OVR #01 SFT
	OVR #03 MUL .color0/g ADD LDZ #02 SFT ( ... g6-cor g6-sel | x* )
	SUB 
	DUP2r [ LIT2r =dither-buffer/g ] ADD2r
	( ... g7-delta-half | x* addr* )
	STH2kr INC2 LDA OVR ADD STH2kr INC2       STA  ( next, add 1/2 )
	                half8s  STH2kr            STAk ( curr, set 1/4 )
	#0001 SUB2  LDA ADD     STH2r  #0001 SUB2 STA  ( prev, add 1/4 )

	NIP ( r7-cor col | x* )
	SWP #01 SFT
	OVR #03 MUL .color0/r ADD LDZ #02 SFT ( col r6-cor r6-sel | x* )
	SUB 
	[ LIT2r =dither-buffer/r ] ADD2r
	( col r7-delta-half | addr* )
	STH2kr INC2 LDA OVR ADD STH2kr INC2       STA  ( next, add 1/2 )
	                half8s  STH2kr            STAk ( curr, set 1/4 )
	#0001 SUB2  LDA ADD     STH2r  #0001 SUB2 STA  ( prev, add 1/4 )
	( fallthrough )


@draw-pixel ( col -- )
	( convert color to pixel )
	DUP #04 LTH ?{
		( set color to foreground, reset #04 bit )
		#40 ORA
	}
	.Screen/pixel DEO
	!advance-screen-pos


( chooses closest color from palette )
( probably the worst method for finding distance )
( |r1-r0| + |g1-g0| + |b1-b0| )
@pick-color ( r7 g7 b7 -- r7 g7 b7 c )
	ROTk #01 rgb-sft
	ROTk ( r7 g7 b7 g6 b6 r6 b6 r6 g6 )
	    [ LIT &color0g $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color0r $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color0b $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) NIP2 NIP JMP2r }
	( DUP ?{ POP2 POP2 #00 JMP2r } )
	[ ,&diff0 STR ]

	ROTk ( r7 g7 b7 g6 b6 r6 b6 r6 g6 )
	    [ LIT &color1g $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color1r $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color1b $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 #01 JMP2r }
	[ ,&diff1 STR ]

	ROTk ( r7 g7 b7 g6 b6 r6 b6 r6 g6 )
	    [ LIT &color2g $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color2r $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color2b $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 #02 JMP2r }
	[ ,&diff2 STR ]

	( r7 g7 b7 g6 b6 r6 )
	    [ LIT &color3r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color3b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color3g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #03 JMP2r }

	#03 SWP ( r7 g7 b7 min-diff-col min-diff )
	[ LIT &diff0 $1 ] LTHk ?{ NIP #00 SWP ROT } POP
	[ LIT &diff1 $1 ] LTHk ?{ NIP #01 SWP ROT } POP
	[ LIT &diff2 $1 ] LTH ?{ POP #02 }
	( r7 g7 b7 min-diff-col )
	JMP2r


@pick-color-uxn38 ( r7 g7 b7 -- r7 g7 b7 col )
	ROTk ( r7 g7 b7 g7 b7 r7 )
	#40 LTH ?{
		( red, magenta, yellow, white )
		#40 LTH ?{
			( magenta, white )
			#40 LTH ?{
				( white )
				Muxn38-w 
				JMP2r
			}
			( magenta(unused): alternate between red and blue )
			[ LIT2 01 -Screen/x-l ] DEI .Screen/y-l DEI EOR AND ?{
				Muxn38-r
				JMP2r
			}
			Muxn38-b
			JMP2r
			( ROTk ROT POP )
			( GTH ?{ )
			( 	Muxn38-r )
			( 	JMP2r )
			( } )
			( Muxn38-b )
			( JMP2r )
		}
		( red, yellow )
		#40 LTH ?{
			( yellow )
			Muxn38-y 
			JMP2r
		}
		( red )
		Muxn38-r 
		JMP2r
	}
	( black, green, blue, cyan )
	#40 LTH ?{
		( blue, cyan )
		#40 LTH ?{
			( cyan )
			Muxn38-c 
			JMP2r
		}
		( blue )
		Muxn38-b 
		JMP2r
	}
	( black, green )
	#40 LTH ?{
		( green )
		Muxn38-g 
		JMP2r
	}
	( black )
	Muxn38-k 
	JMP2r


( assumes screen auto )
@advance-screen-pos ( -- )
	.Screen/x DEI2 .img-w LDZ2 NEQ2 ?{
		#0000 .Screen/x DEO2 
		.Screen/y DEI2 
		( LIT "Y Mdebug-short Mendl )
		( DUP2 #0003 EQU2 ?done )
		INC2
		DUP2 .Screen/y DEO2
		.img-h LDZ2 NEQ2 ?{ 
			Mmode-streaming is-mode ?{
				JMP2r
			}
			!done
		}
		JMP2r
	}
	JMP2r

@on-mouse ( -> )
	.Mouse/scrollx DEI2 LIT "x Mdebug-short Mendl
	.Mouse/scrolly DEI2 LIT "y Mdebug-short Mendl
	BRK




( end )


@done ( -- )
	( #80 .System/state DEO BRK )
	#0000 .Screen/vector DEO2
	;str/end print-str
	BRK



( errors )
	

@bad-file 
	;&str 
!fail-str
	&str "...Bad 20 "file 00


@too-large
	;&str 
!fail-str
	&str "...Too 20 "large 00


@fail-str ( error-msg* -> )
	print-str
( -> )
@fail ( -> )
	LIT "! Mcout
	[ LIT2 01 -System/state ] DEO
	BRK




( utils and stdlib )


@print-str ( str* -- )
	&while ( -- )
		LDAk .Console/write DEO
		INC2 LDAk 
	?&while
	POP2 
	JMP2r


@print-byte ( b -- )
	DUP #04 SFT DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO

	#0f AND DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO
	JMP2r


@inc32-addr ( addr* -- )
	DUP2 INC2 INC2 LDA2 INC2 ( inc lower short )
	DUP2 Mnon-zero2 ?{
		POP2 LDA2k INC2 OVR2 STA2 ( inc upper short )
		#0000
	}
	SWP2 INC2 INC2 STA2	
	JMP2r


( first operand, min and max must be positive, between #00 and #7f )
( second operand can be negative )
( result will be between min and max )
@8+8s-clamp ( as bs min max -- clamp(a+b,min,max) )
	( POP2 LIT2 [ 00 7f ] )
	STH2 ( a bs | min max )

	ADDk
	#80 AND ?{
		( no overflow or underflow )
		ADD
		STHr LTHk ?{ SWP } POP ( less than max? )
		STHr GTHk ?{ SWP } POP ( more than min? )
		JMP2r
	}
	( overflow or underflow )
	NIP
	#80 AND ?{
		( bs is positive )
		STHr POPr JMP2r
	}
	( bs is negative )
	POPr STHr JMP2r
	[ &debug-h $2 &debug-l $2 ]


@half8s ( sb -- sb )
	DUP #80 AND ?{ #01 SFT JMP2r }
	#ff SWP SUB #01 SFT #ff SWP SUB
	JMP2r


@print-sbyte ( sb -- )
	DUP #80 AND ?{ !print-byte }
	LIT "- Mcout #ff SWP SUB INC 
	!print-byte


@str-starts-with ( {str}* {prefix}* -- bool )
	STH2
	STH2
	#00
	&loop
		( index | prefix* str* )
		DUP
		#00 OVR Msk+ LDA
		SWP2r
		#00 ROT Msk+ LDA
		SWP2r
		DUP ?{
			POP2 POP POP2r POP2r #01 JMP2r
		}
		NEQ ?{ 
			INC !&loop
		}
		POP POP2r POP2r #00 JMP2r



( on monochrome screens, colors 0 and 2 are black, 1 and 3 are white )
@palettes [
	&color [ 00 00 00  55 dd ff  99 ff 00  ff 00 00 ]
	&bw    [ 00 00 00  ff ff ff  55 55 55  aa aa aa ]
	&darkb [ 00 00 33  ff ff ff  00 ff 00  ff 00 00 ]
	&kwrg  [ 00 00 00  ff ff ff  00 ff 00  ff 00 00 ]
	&kwrb  [ 00 00 00  ff ff ff  00 00 ff  ff 00 00 ]
	&kwgb  [ 00 00 00  ff ff ff  00 ff 00  00 00 ff ] ( used for uxn38 )
	&detected-from-img ( special palette )
]


@str [
	&init "Hello! 0a 00
	&read "Reading 20 00
	&read-file "file: 20 00
	&read-stdin "standard 20 "input... 0a 00
	&end "Готово! 0a 00
	&usage "Usage: 20 "svitlyna.rom 20 "image.ff 0a 00
	&cannot-fullscreen "Unable 20 "to 20 "resize 20 "screen. 0a 00
	&width "w: 20 00
	&height "h: 20 00
	&after-end "Warning: 20 
	           "input 20 "after 20 "image 20 "end. 0a 00
	&filename-big "File 20 "name 20 "too 20 "big. 0a 00
	&io-error "I/O 20 "error 0a 20 00
	&memory-check "RAM 20 "check 20 "at 20 00
	&memory-error "Not 20 "enough 20 "RAM 0a 20 00
	&part-too-small "Part 20 "too 20 "small 20 "to 20 "split 0a 00
	&uxn38-color-ext "uxn38 20 "color 20 "ext.! 0a 00
	&unexpected-ext "Bad 20 "ext. 20 "ver. 0a 00
]



( http://plastic-idolatry.com/erik/nxu/math32.tal )


@bitcount16 ( x* -> n^ )
    LITr 00 &loop ORAk ?{ POP2 STHr JMP2r } #01 SFT2 INCr !&loop

@bitcount32 ( x** -> n^ )
    SWP2 bitcount16 DUP ?{ POP !bitcount16 } #10 NIP2 ADD JMP2r

( x != 0 )
@non-zero32 ( x** -> bool^ )
    ORA2 ORA JMP2r

( x != y )
@neq32 ( xhi* xlo* yhi* ylo* -> bool^ )
    ROT2 NEQ2 STH NEQ2 STHr ORA JMP2r

( x + y )
@add32 ( xhi* xlo* yhi* ylo* -> zhi* zlo* )
    ROT2 STH2k ADD2 STH2k ROT2 ROT2 GTH2r #00 STHr ADD2 ADD2 SWP2 JMP2r

( x - y )
@sub32 ( x** y** -> z** )
    ROT2 STH2k SWP2 SUB2 STH2k ROT2 ROT2 LTH2r #00 STHr ADD2 SUB2 SWP2 JMP2r

( 16-bit multiplication )
@mul16 ( x* y* -> z** )
    ,&y1 STR ,&y0 STR ( save ylo, yhi )
    ,&x1 STR ,&x0 STR ( save xlo, xhi )
    #0000 ,&z1 STR ,&w0 STR ( reset z1 and w0 )

    ( x1 * y1 => z1z2 )
    LIT2 00 [ &x1 $1 ] LIT2 00 [ &y1 $1 ] MUL2 ,&z3 STR ,&z2 STR

    ( x0 * y1 => z0z1 )
    LIT2 00 _&x0 LDR LIT2 00 _&y1 LDR MUL2 ,&z1 LDR2 ADD2 ,&z1 STR2

    ( x1 * y0 => w1w2 )
    LIT2 00 _&x1 LDR LIT2 00 _&y0 LDR MUL2 ,&w2 STR ,&w1 STR

    ( x0 * y0 => w0w1 )
    LIT2 00 [ &x0 $1 ] LIT2 00 [ &y0 $1 ] MUL2 ,&w0 LDR2 ADD2 ,&w0 STR2

    ( add z and a<<8 )
    #00 LIT2 [ &z1 $1 &z2 $1 ] LIT [ &z3 $1 ]
    LIT2 [ &w0 $1 &w1 $1 ] LIT [ &w2 $1 ] #00
    !add32

( x * y )
@mul32 ( x** y** -> z** )
    ROT2k ( x0* x1* y0* y1* y0* y1* x1* )
    mul16 ,&z1 STR2 ,&z0 STR2 POP2 ( x0* x1* y0* y1* ; sum = [x1*y1] )
    STH2 ROT2 STH2                 ( x1* y0* [y1* x0*] )
    MUL2r MUL2 STH2r ADD2          ( x1*y0+y1*x0* )
    ( [x0*y0]<<32 will completely overflow )
    LIT2 [ &z0 $2 ] ADD2 ( sum += [x0*y1+x1*y0]<<16 )
    LIT2 [ &z1 $2 ] JMP2r

( x >> n )
@rshift32 ( x** n^ -> x>>n )
    DUP #08 LTH ?shift32-0 ( x n )
    DUP #10 LTH ?rshift32-1 ( x n )
    DUP #18 LTH ?rshift32-2 ( x n )
    !rshift32-3 ( x n )

( shift by 0-7 bits; used by both lshift and rshift )
@shift32-0 ( x** n^ -> x>>n )
    STH DUP2 STHkr SFT2                       ,&z2 STR2
    POP DUP2 STHkr SFT2 ,&z2 LDR ORA ,&z2 STR ,&z1 STR
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    LIT [ &z1 $1 ] LIT2 [ &z2 $2 ] JMP2r

( x << n )
@lshift32 ( x** n^ -> x<<n )
    DUP #08 LTH ?lshift32-0 ( x n )
    DUP #10 LTH ?lshift32-1 ( x n )
    DUP #18 LTH ?lshift32-2 ( x n )
    !lshift32-3 ( x n )

( shift right by 8-15 bits )
@rshift32-1 ( x** n^ -> x>>n )
    #08 SUB STH                 ( stash [n>>8] )
    POP DUP2 STHkr SFT2 ,&z2 STR2
    POP      STHr  SFT2 ,&z2 LDR ORA ,&z2 STR
    #00 SWP LIT2 [ &z2 $2 ] JMP2r

( shift right by 16-23 bits )
@rshift32-2 ( x** n^ -> x>>n )
    #10 SUB STH                 ( stash [n>>16] )
    POP2 STHr SFT2 #0000 SWP2 JMP2r

( shift right by 16-23 bits )
@rshift32-3 ( x** n^ -> x>>n )
    #18 SUB STH                 ( stash [n>>24] )
    POP2 POP STH SWPr SFTr #00 #0000 STHr JMP2r

( shift left by 0-7 bits )
@lshift32-0 ( x** n^ -> x<<n )
    #40 SFT !shift32-0

( shift left by 8-15 bits )
@lshift32-1 ( x** n^ -> x<<n )
    #08 SUB #40 SFT STH ( stash [n-8]<<4 )
        DUP2 STHkr SFT2 ,&z1 STR2
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    NIP LIT2 [ &z1 $2 ] #00 JMP2r

( shift left by 16-23 bits )
@lshift32-2 ( x** n^ -> x<<n )
    #10 SUB #40 SFT STH ( stash [n-16]<<4 )
    NIP2 STHr SFT2 #0000 JMP2r

( shift left by 24-31 bits )
@lshift32-3 ( x** n^ -> x<<n )
    #18 SUB #40 SFT ( stash [n-24]<<4 )
    SFT NIP2 NIP #0000 #00 JMP2r

( x < y )
@lt32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 JMP2r } GTH2 #00 EQU JMP2r

( x > y )
@gteq32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 #00 EQU JMP2r } GTH2 JMP2r

( x / y )
@div32 ( x** y** -> q** )
    z_divmod32 ;z_divmod32/quo0 LDA2 ;z_divmod32/quo1 LDA2 JMP2r

( private: calculate and store x / y and x % y )
@z_divmod32 ( x** y** -> )
    ( ; store y and x for repeated use )
    #0000 DUP2 ,&quo0 STR2 ,&quo1 STR2      ( x** y**         ; quo<-0 )
    STH2k ,&div1 STR2 STH2k ,&div0 STR2     ( x** [ylo* yhi*] ; div<-y )
    OVR2 OVR2 ,&rem1 STR2 ,&rem0 STR2       ( x** [ylo* yhi*] ; rem<-x )
    OVR2 OVR2 STH2r STH2r                   ( x** x** y** )
    OVR2 OVR2 STH2 STH2                     ( x** x** y** [ylo* yhi*] )
    gteq32 ?{ POP2 POP2 POP2r POP2r JMP2r } ( x** [ylo* yhi*] ; return if x < y )

    ( ; bitcount[x] - bitcount[y] determines largest multiple of y to try )
    bitcount32 STH2r STH2r bitcount32 SUB ( shift=rbits-dits^ )
    #00 DUP2                              ( shift^ 0^ shift^ 0^ )
    #0000 INC2k ROT2 POP                  ( shift^ 0^ 0* 1* shift^ )
    lshift32 ,&cur1 STR2 ,&cur0 STR2      ( shift^ 0^ ; cur<-1<<shift )
    ,&div0 LDR2 ,&div1 LDR2 ROT2 POP      ( div** shift^ )
    lshift32 ,&div1 STR2 ,&div0 STR2      ( ; div<-div<<shift )

    &loop
      ( ; if rem >= cur [current divisor], we can subtract it and add to quotient )
      ( ; otherwise, skip that iteration and reduce cur. )
      LIT2 [ &rem0 $2 ] LIT2 [ &rem1 $2 ] ,&div0 LDR2 ,&div1 LDR2
      lt32 ?{
        ( ; since rem >= div, we have found a multiple of y that divides x )
        ,&rem0 LDR2 ,&rem1 LDR2             ( rem** )
        LIT2 [ &div0 $2 ] LIT2 [ &div1 $2 ] ( rem** div** )
        sub32 ,&rem1 STR2 ,&rem0 STR2       ( ; rem<-rem-div** )
        LIT2 [ &quo0 $2 ] LIT2 [ &quo1 $2 ] ( quo** )
        LIT2 [ &cur0 $2 ] LIT2 [ &cur1 $2 ] ( quo** cur** )
        add32 ,&quo1 STR2 ,&quo0 STR2       ( ; quo<-quo+cur** )
      }
      ,&div0 LDR2 ,&div1 LDR2 #01 rshift32 ( div>>1** )
      ,&div1 STR2 ,&div0 STR2              ( ; div<-div>>1 )
      ,&cur0 LDR2 ,&cur1 LDR2 #01 rshift32 ( cur>>1** )
      OVR2 OVR2 ,&cur1 STR2 ,&cur0 STR2    ( cur>>1** ; cur<-cur>>1 )
      non-zero32 ?&loop JMP2r              ( ; loop if cur>0, else we're done )


@part [ 
	( partition boundaries: start inclusive, end inclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00   
	&b-beg 00 &b-end 00   
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part1 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part2 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part3 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part4 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part5 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part6 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@part7 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0200 &g-sort $0200 &b-sort $0200
]

@filename "image.ff $0800
@file-buf-pre $20 @file-buf [ $3fe0 &pre-end $20 &end ]


( signed 8-bit values of quantization errors. divided by 2 )
( 0x1000 = 4096 pixels per line max )
( a couple bytes of padding, so that dithering algorithm does not need
  to check bounds )
@dither-buffer [ 
	$1 &r $1000 ( end ) $1
	$1 &g $1000 ( end ) $1
	$1 &b $1000 ( end ) $1
]
@end
