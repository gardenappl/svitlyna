|00 @System [ 
	&vector $2 &expansion $2 &wst $1 &rst $1 
	&metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1 
]
|10 @Console [ 
	&vector $2 &read $1 &pad $4 
	&type $1 &write $1 &error $1600
]
|20 @Screen [ 
	&vector $2 &width $2 &height $2 &auto $1 &pad 
	$1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1600
]
|a0 @File [ 
	&vector $2 &success $2 &stat $2 &delete $1 
	&append $1 &name $2 &length $2 &read $2 &write $2000
]

|0000 
@img-w $2 @img-h $2 

( see bottom of file for reasoning )
%Mmax-w-smol { #0200 }
%Mmax-w-big { #1000 }

( boolean options, could be compressed to bit fields if needed )
( dithering requires use of large memory buffers for lines )
@no-dithering $1
@no-fullscreen $1

@color0 [ &r $1 &g $1 &b $1 ]
@color1 [ &r $1 &g $1 &b $1 ]
@color2 [ &r $1 &g $1 &b $1 ]
@color3 [ &r $1 &g $1 &b $1 ]

%Mprint-short { SWP print-byte print-byte }
%Mendl { #0a .Console/write DEO }


|0100
( hardcoded colors for now )
#ffff .color0 STZ2 #ff .color0/b STZ
#9999 .color1 STZ2 #99 .color1/b STZ
#5555 .color2 STZ2 #55 .color2/b STZ
#0000 .color3 STZ2 #00 .color3/b STZ
prepare-palette


#01 .Screen/auto DEO

.Console/type DEI ?{ ;read-stdin .Console/vector DEO2 BRK }
;read-argument .Console/vector DEO2
BRK

@read-stdin ( -> )
	;buffer #000e read-n-stdin-bytes ?{ BRK }
	;str/start print-str ;str/start-stdin print-str Mendl
	;read-stdin-hack .Console/vector DEO2 
( -> )
@read-stdin-hack ( -> )
	;buffer/ffheightlow #0002 read-n-stdin-bytes ?{ BRK }
	ff-init
	;ff-print-stdin .Console/vector DEO2
	!ff-print-stdin
BRK


@read-argument ( -> )
	.Console/type DEI 
	DUP #03 NEQ ?{
		;str/usage !fail-str
	}
	#02 EQU ?{ 
		#0000 .Console/vector DEO2
		;on-read-argument .Screen/vector DEO2
		BRK
	}
	.Console/read DEI 
	[ ,&name-length LDR2 ] ;filename ADD2 STA
	[ ,&name-length LDR2 ] INC2 [ ,&name-length STR2 ]
BRK 
	&name-length 0000


@on-read-argument ( -> )
	#0000 .Screen/vector DEO2
	;str/start print-str
	;str/start-file print-str
	;filename print-str
	Mendl
	

	 ;filename .File/name DEO2
	#000e .File/length DEO2 ;buffer .File/read DEO2
	.File/success DEI2 #000e GTH2 ?bad-file

	;buffer/magic LDA LIT "f NEQ ?bad-file
	#0002 .File/length DEO2 ;buffer/ffheightlow .File/read DEO2
	ff-init
	;ff-print-file .Screen/vector DEO2
BRK


@ff-print-stdin ( -> )
	LIT ". .Console/write DEO
	;ff-get-next-color/buffer #0008 
	LIT "R .Console/write DEO
	read-n-stdin-bytes ?{ 
		LIT "A .Console/write DEO 
		;ff-print-stdin Mprint-short
		.Console/vector DEI2 Mprint-short
	BRK }

	;ff-print-stdin Mprint-short
	.Console/vector DEI2 Mprint-short
	LIT ") .Console/write DEO
	ff-get-next-color
	;color/b STA ;color/g STA ;color/b STA
	pick-color .Screen/pixel DEO
	move-print-pos ?{
		LIT "M .Console/write DEO
		;str/end print-str 
		#0000 .Console/vector DEO2 
	}
	LIT "N .Console/write DEO
	!ff-print-stdin
BRK


@ff-print-file ( -> )
	#0008 .File/length DEO2

	&loop ( -- )
		( LIT ". .Console/write DEO )
		;ff-get-next-color/buffer .File/read DEO2
		ff-get-next-color
		;color/b STA ;color/g STA ;color/b STA
		pick-color .Screen/pixel DEO
		move-print-pos 
	?&loop

	;str/end print-str 
	#0000 .Screen/vector DEO2
BRK


@ff-init ( -- )
	#0000
	&loop
		DUP2k
		;&magic ADD2 LDA DUP #00 NEQ ?{ Mendl !ff-size }
		ROT ROT ;buffer/magic ADD2 LDA DUP .Console/write DEO NEQ ?bad-file
		INC2 
	!&loop
	[ &magic "farbfeld 00 ]
( -> )

@ff-size
	;buffer/ffwidthhigh LDA2 #0000 EQU2 ?{ !too-large }
	;buffer/ffwidthlow LDA2 DUP2 .img-w STZ2
	;buffer/ffheighthigh LDA2 #0000 EQU2 ?{ !too-large }
	;buffer/ffheightlow LDA2 DUP2 .img-h STZ2

	handle-image-size
JMP2r


@move-print-pos ( -- continue )
	.Screen/x DEI2 Mprint-short
	.Screen/y DEI2 Mprint-short
	LIT "E .Console/write DEO
	.Screen/x DEI2 .img-w LDZ2 NEQ2 ?{
		#0000 .Screen/x DEO2 
		.Screen/y DEI2 INC2 
		DUP2 .Screen/y DEO2 
		.img-h LDZ2 NEQ2
	JMP2r }
	#01
JMP2r

	
( farbfeld uses 16-bit depth, not alpha-premultiplied ) 
( we discard the lower 12 bits )
( use 4 bits directly, if alpha is not present )
( or, multiply 2 bit color with 2 bit alpha to get 4 bits )
@ff-get-next-color ( -- r g b )
	,&a LDR INC ?&trans

	( LIT "# .Console/write DEO )
	,&r LDR ( #04 SFT )
	( DUP print-byte  )
	,&g LDR ( #04 SFT )
	( DUP print-byte  )
	,&b LDR ( #04 SFT )
	( DUP print-byte  )
	( #0a .Console/write DEO )
	JMP2r 
	[ &buffer &r $2 &g $2 &b $2 &a $2 ]

	&trans
		( LIT "a .Console/write DEO )
		( LIT "# .Console/write DEO )
		( ,&r LDR print-byte )
		( ,&g LDR print-byte )
		( ,&b LDR print-byte )
		( LIT "# .Console/write DEO )
		,&r LDR #06 SFT 
		,&a LDR #06 SFT MUL
		( DUP print-byte  )
		,&g LDR #06 SFT 
		,&a LDR #06 SFT MUL
		( DUP print-byte  )
		,&b LDR #06 SFT 
		,&a LDR #06 SFT MUL
		( DUP print-byte  )
		( #0a .Console/write DEO )
JMP2r


@handle-image-size
	;str/height print-str DUP2 Mprint-short Mendl
	DUP2 .Screen/height DEO2
	DUP2 .Screen/height DEI2 EQU2 ?{
		#01 .no-fullscreen STZ
	}
	OVR2
	DUP2 .Screen/width DEO2
	;str/width print-str DUP2 Mprint-short Mendl
	DUP2 .Screen/width DEI2 EQU2 ?{
		#01 .no-fullscreen STZ
	}
	OVR2
	.no-fullscreen LDZ SUB ?{ ;str/cannot-fullscreen !fail-str }

	Mmax-w-smol LTH2 ?{ 
		( memory check )
		LIT "! #ffff STA
		#ffff LDA LIT "! EQU ?{
			#01 .no-dithering STZ 
		}
		LIT "? #ffff STA
		#ffff LDA LIT "? EQU ?{
			#01 .no-dithering STZ 
		}
	}

	Mmax-w-big LTH2 ?{ 
		#01 .no-dithering STZ 
	}
	.no-fullscreen LDZ SUB ?{ ;str/cannot-fullscreen !fail-str }
JMP2r


( probably overkill )
@prepare-palette
	;color0/r LDA DUP ;color0r STA #f0 AND 
	;color1/r LDA DUP ;color1r STA #04 SFT ORA ,&rhigh STR
	;color2/r LDA DUP ;color2r STA #f0 AND 
	;color3/r LDA DUP ;color3r STA #04 SFT ORA ,&rlow STR
	;color0/g LDA DUP ;color0g STA #f0 AND 
	;color1/g LDA DUP ;color1g STA #04 SFT ORA ,&ghigh STR
	;color2/g LDA DUP ;color2g STA #f0 AND 
	;color3/g LDA DUP ;color3g STA #04 SFT ORA ,&glow STR
	!{
		&r &rhigh 00 &rlow 00
		&g &ghigh 00 &glow 00
		&b &bhigh 00 &blow 00
	}
	;color0/b LDA DUP ;color0b STA #f0 AND 
	;color1/b LDA DUP ;color1b STA #04 SFT ORA ,&bhigh STR
	;color2/b LDA DUP ;color2b STA #f0 AND 
	;color3/b LDA DUP ;color3b STA #04 SFT ORA ,&blow STR

	,&r LDR2 .System/r DEO2
	,&g LDR2 .System/g DEO2
	,&b LDR2 .System/b DEO2
JMP2r


( chooses closest color from palette )
@pick-color ( -- c )
	#00 [ ,color/r LDR ] [ LIT @color0r $1 ] GTHk ?{ SWP } SUB
	#00 [ ,color/g LDR ] [ LIT @color0g $1 ] GTHk ?{ SWP } SUB ADD2
	#00 [ ,color/b LDR ] [ LIT @color0b $1 ] GTHk ?{ SWP } SUB ADD2
	,color/mindist STR2 #00 ,color/mindistcol STR
	
	#0000
	#00 [ ,color/r LDR ] [ LIT @color1r $1 ] GTHk ?{ SWP } SUB
	#00 [ ,color/g LDR ] [ LIT @color1g $1 ] GTHk ?{ SWP } SUB ADD2
	#00 [ ,color/b LDR ] [ LIT @color1b $1 ] GTHk ?{ SWP } SUB ADD2
	DUP2 ,color/mindist LDR2 GTH2 
	?{ DUP2 ,color/mindist STR2 #01 ,color/mindistcol STR } POP2
	
	!{
		@color [ 
			&r 00 &g 00 &b 00 &mindist ffff &mindistcol 00 
		]
	}
	#0000
	#00 [ ,color/r LDR ] [ LIT @color2r $1 ] GTHk ?{ SWP } SUB
	#00 [ ,color/g LDR ] [ LIT @color2g $1 ] GTHk ?{ SWP } SUB ADD2
	#00 [ ,color/b LDR ] [ LIT @color2b $1 ] GTHk ?{ SWP } SUB ADD2
	DUP2 ,color/mindist LDR2 GTH2 
	?{ DUP2 ,color/mindist STR2 #02 ,color/mindistcol STR } POP2
	
	#0000
	#00 [ ,color/r LDR ] [ LIT @color3r $1 ] GTHk ?{ SWP } SUB
	#00 [ ,color/g LDR ] [ LIT @color3g $1 ] GTHk ?{ SWP } SUB ADD2
	#00 [ ,color/b LDR ] [ LIT @color3b $1 ] GTHk ?{ SWP } SUB ADD2
	DUP2 ,color/mindist LDR2 GTH2 
	?{ DUP2 ,color/mindist STR2 #03 ,color/mindistcol STR } POP2

	;color/mindistcol LDA
JMP2r
	

@print-str ( str* -- )
	&while ( -- )
		LDAk .Console/write DEO
		INC2 LDAk 
	?&while
	POP2 
JMP2r

@print-byte ( b -- )
	DUP #04 SFT DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO

	#0f AND DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO
JMP2r

@read-n-stdin-bytes ( addr* n* -- continue )
	[ ,&count LDR2 ] DUP2 
	ROT2 NEQ2 ?{
		#0000 [ ,&count STR2 ] #00 ROT ROT STA #01 JMP2r
	}
	DUP2 INC2 [ ,&count STR2 ]
	ADD2 .Console/read DEI ROT ROT STA
	#00
JMP2r	
	&count 0000
	

@bad-file 
	;&str 
!fail-str
	&str "...Bad 20 "file 00


@too-large
	;&str 
!fail-str
	&str "...Too 20 "large 00


@fail-str ( error-msg* -> )
	print-str
( -> )
@fail ( -> )
	#01 .System/state DEO
BRK


@str [
	&start "Reading 20 00
	&start-file "file: 20 00
	&start-stdin "standard 20 "input... 00
	&end "Готово! 0a 00
	&usage "Usage: 20 "svitlyna.rom 20 "image.ff 0a 00
	&cannot-fullscreen "Unable 20 "to 20 "resize 20 "screen 0a 00
	&width "w: 20 00
	&height "h: 20 00
]

@buffer [
	&magic                       $4
	              &qoiwidthhigh  $2
	              &qoiwidthlow   $2
	&ffwidthhigh  &qoiheighthigh $2
	&ffwidthlow   &qoiheightlow  $2
	&ffheighthigh &qoichan       $1
	              &qoispace      $1
	&ffheightlow                 $2 
]



( 9 lines are needed: at least 8 to export a sprite,
  multiple of 3 to use dithering )
( smol 
	lines:   #1000-#1d80
	         0x0180 = 384 bytes per line
	         384 / 3 * 4 = 512 pixels per line
	sprites: #1d80-#1ddd
	         0x0080 = 128 bytes total
		 128 * 4 = 512 pixels per line )
|1000 @line-1-smol !fail ( upper limit for 'smol' code )
@filename
|1180 @line-2-smol 
|1300 @line-3-smol
|1480 @line-4-smol
|1600 @line-5-smol
|1780 @line-6-smol
|1900 @line-7-smol
|1a80 @line-8-smol
|1c00 @line-9-smol
|1d80 @sprite-smol

( big, is 8x smol
	lines:   #8000-#f400
	         0x0c00 = 3072 bytes per line
	         3072 / 3 * 4 = 4096 pixels per line
	sprites: #ec00-#f000
	         0x0400 = 1024 bytes total
		 1024 * 4 = 4096 pixels per line )
|8000 @line-1-big
|8c00 @line-2-big
|9800 @line-3-big
|a400 @line-4-big
|b000 @line-5-big
|bc00 @line-6-big
|c800 @line-7-big
|d400 @line-8-big
|e000 @line-9-big
|ec00 @sprite-big
