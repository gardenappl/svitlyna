|00 @System [ 
	&vector $2 &expansion $2 &wst $1 &rst $1 
	&metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1 
]
|10 @Console [ 
	&vector $2 &read $1 &pad $4 
	&type $1 &write $1 &error $1
]
|20 @Screen [ 
	&vector $2 &width $2 &height $2 &auto $1 &pad 
	$1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1600
]
|80 @Controller [
	&vector $2 &button $1 &key $1
]
|a0 @File [ 
	&vector $2 &success $2 &stat $2 &delete $1 
	&append $1 &name $2 &length $2 &read $2 &write $2
]

|0000 

( color channels )
%Mr { #00 } %Mg { #01 } %Mb { #02 }

@decode-x $2 @decode-y $2 
@xfrac $2 @yfrac $2
@img-w $2 @img-h $2 @img-size $4

%Mmax-width { #1000 }
%Mmax-height { #1000 }
%Mmax-name-length { #07ff }

( 8-bit linear RGB colors, used for most processing )
( display device palette is in sRGB )
@color0 [ &r $1 &g $1 &b $1 ]
@color1 [ &r $1 &g $1 &b $1 ]
@color2 [ &r $1 &g $1 &b $1 ]
@color3 [ &r $1 &g $1 &b $1 ]

( 7-bit linear RGB colors, used for dithering, 
  one bit reserved for signed arithmetic with quantization errors )
@color0-7 [ &r $1 &g $1 &b $1 ]
@color1-7 [ &r $1 &g $1 &b $1 ]
@color2-7 [ &r $1 &g $1 &b $1 ]
@color3-7 [ &r $1 &g $1 &b $1 ]

%Mfile-buffer-length { #4000 }


@part-split-step $1
@current-palette $2
@current-mode $1
%Mmode-streaming { #01 }
%Mmode-no-dithering { #02 }
%Mmode-partition-color-func { #04 }

%Mcout { .Console/write DEO }
%Mendl { #0a Mcout }

%Mprint-short { SWP print-byte print-byte }
%Mdebug-byte { Mcout DUP print-byte }
%Mdebug-short { Mcout OVR print-byte DUP print-byte }
%Mdebug32 { Mcout OVR2 Mprint-short DUP2 Mprint-short }
%Mdebug-rgb { 
	Mcout LIT "# Mcout 
	ROT DUP print-byte 
	ROT DUP print-byte
	ROT DUP print-byte
}

%Mprint-bgr { 
	LIT "# Mcout 
	print-byte print-byte print-byte Mendl 
}
%Mprint-rgb { 
	LIT "# Mcout 
	STH OVR print-byte 
	DUP print-byte
	STHr DUP print-byte Mendl
}

( common pattern for adding offset to pointer )
%Msk+ { STH2kr ADD2 }
%Ms+ { STH2r ADD2 }

%Mload32 { LDA2k SWP2 INC2 INC2 LDA2 }
%Mnon-zero2 { ORA }


|0100
( init )
	( memory check )
	;str/memory-check print-str
	;end Mprint-short
	#1234 ;end STA2
	;end LDA2 #1234 EQU2 ?{ ;str/memory-error !fail }
	LIT 20 Mcout LIT "O Mcout LIT "K Mcout Mendl

	;str/init print-str

	;on-controller-input .Controller/vector DEO2

	.Console/type DEI ?{ 
		;read-stdin .Console/vector DEO2	
		;palettes/color .current-palette STZ2
		prepare-palette-builtin
		Mmode-streaming .current-mode STZ
		;str/read print-str ;str/read-stdin print-str

		;detect-magic set-on-bytes-received
		#0008 set-bytes-expected
		;display set-on-pixel-received

		!display-init
	}
	;read-argument .Console/vector DEO2
	BRK


@read-stdin ( -> )
	[ LIT2 &index 0000 ] 
	DUP2 ;file-buf ADD2 
	.Console/read DEI ROT ROT STA
	INC2 DUP2 [ LIT2 &bytes-expected $2 ] NEQ2 ?{
		( call subroutine )
		;file-buf [ LIT2 &on-bytes-received $2 ] JSR2
		POP2 #0000 [ ,&index STR2 ]
		BRK
	}
	[ ,&index STR2 ]
	BRK


@read-argument ( -> )
	.Console/type DEI 
	DUP #03 NEQ ?{
		;str/usage !fail-str
	}
	#02 EQU ?{ 
		#00 [ ,&name-length LDR2 ] ;filename ADD2 STA
		Mendl
		
		LIT2 00 -part-split-step STZ
		( ;palettes/bw .current-palette STZ2 )
		( prepare-palette-builtin )
		( !display-init )
		;palettes/detected-from-img .current-palette STZ2
		!palette-split-init
	}
	.Console/read DEI 
	[ ,&name-length LDR2 ] ;filename ADD2 STA
	[ ,&name-length LDR2 ] INC2 
	DUP2 Mmax-name-length LTH2 ?{
		;str/filename-big !fail-str
	}

	[ ,&name-length STR2 ]
	BRK 
&name-length 0000


@read-file ( -> )
	;str/read print-str ;str/read-file print-str
	;filename print-str Mendl

	;detect-magic set-on-bytes-received
	#0008 set-bytes-expected

	;filename .File/name DEO2
	Mfile-buffer-length .File/length DEO2

	;file-buf ;read-buffer/window STA2
	;read-buffer .Screen/vector DEO2
	BRK


@read-buffer ( -> )
	;file-buf 
	DUP2 .File/read DEO2
	.File/success DEI2 ADD2 [ ,&window-end STR2 ]

	&loop
		[ LIT2 &window =file-buf ] 
		DUP2 [ LIT2 &bytes-expected $2 ] ADD2 ( next window )
		[ LIT2 &window-end =file-buf/end ]
		GTH2k ?{
			POP2
			[ ,&window STR2 ]
			[ LIT2 &on-bytes-received $2 ] JSR2
			!&loop

			( copy cmd )
			&cmd [ 
				01 0020 0000 =file-buf/pre-end 
				0000 =file-buf-pre 
			]
		}
		( not enough bytes )

		;file-buf/end NEQ2 ?{
			( buffer full )
			( copy last 20 bytes to pre-buffer )
			;&cmd .System/expansion DEO2
			POP2
			Mfile-buffer-length SUB2 [ ,&window STR2 ]

			( a good time to take a break? )
			[ LIT &break-counter 00 ] INC
			DUP #10 NEQ ?{
				POP #00 [ ,&break-counter STR ]
				BRK	
			}
			[ ,&break-counter STR ]
			!read-buffer
		}
		#0000 .Screen/vector DEO2
		[ LIT2 &on-file-end $2 ] JMP2


@set-on-bytes-received ( {routine}* -- )
	DUP2 ;read-buffer/on-bytes-received STA2
	     ;read-stdin/on-bytes-received STA2
	JMP2r


@set-bytes-expected ( bytes* -- )
	DUP2 ;read-buffer/bytes-expected STA2
	     ;read-stdin/bytes-expected STA2
	JMP2r


@set-on-pixel-received ( bytes* -- )
	DUP2 ;ff-next-pixel/on-pixel-received STA2
	     ;qoi-on-pixel-received/routine STA2
	JMP2r


@set-on-file-end ( bytes* -- )
	;read-buffer/on-file-end STA2
	JMP2r




( ui )

@on-controller-input ( -> )
	.Controller/button DEI 		
	DUP #01 AND ?on-a-ctrl
	DUP #02 AND ?on-b-alt
	DUP #10 AND ?on-dpad-up
	    #20 AND ?on-dpad-down
	BRK


@on-a-ctrl ( -> )
	Mmode-streaming is-mode ?end
	;palettes/detected-from-img .current-palette STZ2

	.part-split-step LDZ [ #03 ] EQU ?{
		!palette-split-init
	}

	prepare-palette-avg
	!display-init


@on-b-alt ( -> )
	Mmode-streaming is-mode ?end
	.current-palette LDZ2 ;palettes/detected-from-img NEQ2 ?{ 
		Mmode-partition-color-func is-mode ?{
			Mmode-partition-color-func #01 set-mode
			!display-init
		}
		Mmode-partition-color-func #00 set-mode
		( also toggle dithering, allowing 4 modes )
	}
	Mmode-no-dithering is-mode ?{
		Mmode-no-dithering #01 set-mode
		!display-init
	}

	Mmode-no-dithering #00 set-mode
	!display-init


@on-dpad-up ( -> )
	Mmode-streaming is-mode ?end
	.current-palette LDZ2 
	#000c ADD2
	DUP2 ;palettes/detected-from-img LTH2 ?{
		POP2 ;palettes
	}
	.current-palette STZ2
	prepare-palette-builtin
	!display-init


@on-dpad-down ( -> )
	Mmode-streaming is-mode ?end
	.current-palette LDZ2
	DUP2 ;palettes GTH2 ?{
		POP2 ;palettes/detected-from-img
	}
	#000c SUB2
	.current-palette STZ2
	prepare-palette-builtin
	!display-init


@is-mode ( mode -- bool )
	.current-mode LDZ AND
	JMP2r


@set-mode ( mode value -- bool )
	?{ .current-mode LDZ EOR .current-mode STZ JMP2r }
	.current-mode LDZ ORA .current-mode STZ
	JMP2r




( image formats )


@detect-magic ( {buffer}* -- )
	DUP2 ;&farbfeld str-starts-with ?{
		!&try-qoi
	}
	;&farbfeld print-str Mendl
	POP2
	;ff-size set-on-bytes-received
	#0008 set-bytes-expected
	JMP2r

	[ &farbfeld "farbfeld 00 ]
	[ &qoif "qoif 00 ]

	&try-qoi
	DUP2 ;&qoif str-starts-with ?{
		!bad-file
	}
	;&qoif print-str Mendl
	!qoi-header1


@ff-size ( {buffer}* -- )
	          LDA2k Mnon-zero2 ?too-large
	INC2 INC2 LDA2k ( width ) SWP2 
	INC2 INC2 LDA2k Mnon-zero2 ?too-large
	INC2 INC2 LDA2 ( height )

	handle-image-size

	;ff-next-pixel set-on-bytes-received
	#0008 set-bytes-expected
	JMP2r

	
( farbfeld uses 16-bit depth, not alpha-premultiplied ) 
( we don't load the lower 8 bits )
@ff-next-pixel ( {buffer}* -- )
	STH2k #0006 ADD2 LDA ( alpha )
	( 255 INC becomes 0, so lambda isn't skipped -> opaque )
	INCk ?{
		( alpha is zero )
		POP
		LDAkr STHr     ( r )
		#0002 Msk+ LDA ( g )
		#0004 Ms+  LDA ( b )
		!&result
	}
	#00 SWP
	DUP2 #00 LDAkr STHr     MUL2 POP (    00 aa ar )
	ROT ROT
	DUP2 #00 #0002 Msk+ LDA MUL2 POP ( ar 00 aa ag )
	ROT ROT
	     #00 #0004 Ms+  LDA MUL2 POP ( ar ag ab )
	&result
	srgb-to-linear
	[ LIT2 &on-pixel-received $2 ] JMP2


@alpha-multiply ( r g b a -- r*a g*a b*a )
	INCk ?{ POP JMP2r } ( don't multiply if opaque )
	( r g b a )
	STHk #00 ROT #00 STHr MUL2 POP STH 
	( r g a | b*a )
	STHk #00 ROT #00 STHr MUL2 POP STH 
	( r a | b*a g*a )
	STH  #00 SWP #00 STHr MUL2 POP
	STH2r SWP2r
	JMP2r


@qoi-header1 ( {buffer}* -- )
	#0004 ADD2
	( width )
	DUP2 LDA2 Mnon-zero2 ?too-large
	INC2 INC2 LDA2 ;&w STA2

	;qoi-header2 set-on-bytes-received
	#0006 set-bytes-expected
	JMP2r
&w $2


@qoi-header2 ( {buffer}* -- )
	( height )
	LDA2k Mnon-zero2 ?too-large
	INC2 INC2 LDA2k
	( width, again )
	;qoi-header1/w LDA2

	SWP2 handle-image-size

	INC2 INC2 INC2 ( ignore channel count )
	LDA 
	LIT "S Mdebug-byte Mendl
	;qoi-is-linear STA
	
	;qoi-last
	&loop
		#0000 OVR2 STA2
		INC2 INC2
		DUP2 ;qoi-index/end LTH2
	?&loop
	POP2
	#ff ;qoi-last/a STA

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r


@qoi-last  [ &r $1  &g $1  &b $1  &a $1  ]
@qoi-index [ &r $40 &g $40 &b $40 &a $40 ] &end $2

%Mqoi-stlast {
	STH2 DUP2 ;qoi-last/r STA2 
	STH2r DUP2 ;qoi-last/b STA2
}


@qoi-stindex ( r g b a -- r g b a )
	SWP2k
	( r g b a b a r g )
	    #05 MUL     ( 5g )
	SWP #03 MUL ADD ( 3r )
	SWP #0b MUL ADD ( 11a )
	SWP #07 MUL ADD ( 7b )
	#3f AND LITr 00 STH
	SWP2k
	;qoi-index/g Msk+ STA
	;qoi-index/r Msk+ STA
	;qoi-index/a Msk+ STA
	;qoi-index/b Ms+  STA
	JMP2r


@qoi-chunk ( {buffer}* -- )
	LDA
	( QOI_OP_RGB )
	#fe NEQk ?{
		POP2
		;qoi-chunk-rgb set-on-bytes-received
		#0003 set-bytes-expected
		JMP2r
	}
	POP
	( QOI_OP_RGBA )
	#ff NEQk ?{
		POP2
		;qoi-chunk-rgba set-on-bytes-received
		#0004 set-bytes-expected
		JMP2r
	}
	POP
	( QOI_OP_INDEX )
	DUP #06 SFT ?{
		( 7 6 5 4 3 2 1 0 )
		( 0 0|   index    )
		#00 SWP #3f AND STH2
		;qoi-index/r Msk+ LDA
		;qoi-index/g Msk+ LDA
		;qoi-index/b Msk+ LDA
		;qoi-index/a Ms+ LDA
		Mqoi-stlast
		alpha-multiply
		!qoi-on-pixel-received
	}
	( QOI_OP_DIFF )
	DUP #06 SFT #01 NEQ ?{
		( 7 6 5 4 3 2 1 0 )
		( 0 1| dr| dg| db )
		DUP #04 SFT #03 AND ;qoi-last/r LDA ADD #02 SUB 
		OVR #02 SFT #03 AND ;qoi-last/g LDA ADD #02 SUB 
		ROT         #03 AND ;qoi-last/b LDA ADD #02 SUB 
			            ;qoi-last/a LDA
		Mqoi-stlast
		qoi-stindex
		alpha-multiply
		!qoi-on-pixel-received
	}
	( QOI_OP_LUMA )
	DUP #06 SFT #02 NEQ ?{
		( 7 6 5 4 3 2 1 0 | 7 6 5 4 3 2 1 0 )
		( 1 0| diff green |  dr-rg | db-dg  )
		#3f AND ;qoi-chunk-luma/dg STA
		;qoi-chunk-luma set-on-bytes-received
		#0001 set-bytes-expected
		JMP2r
	}
	( QOI_OP_RUN )
	( 7 6 5 4 3 2 1 0 )
	( 1 1| run length )
	#3f AND INC
	;qoi-last/r LDA
	;qoi-last/g LDA
	;qoi-last/b LDA
	;qoi-last/a LDA
	alpha-multiply
	ROT STH STH2
	#00
	( wst: length count | rst: r g b )
	&run-loop
		ROTkr STHr STH2r
		( wst: length count r g b | rst: r g b )
		qoi-on-pixel-received
		INC
		NEQk 
	?&run-loop
	POP2 POP2r POPr
	JMP2r


@qoi-chunk-rgb ( {buffer}* -- )
	             LDAk
	ROT ROT INC2 LDAk 
	ROT ROT INC2 LDA
	;qoi-last/a LDA

	qoi-stindex
	Mqoi-stlast

	alpha-multiply
	qoi-on-pixel-received

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r


@qoi-chunk-rgba ( {buffer}* -- )
	             LDAk 
	ROT ROT INC2 LDAk 
	ROT ROT INC2 LDAk
	ROT ROT INC2 LDA

	qoi-stindex
	Mqoi-stlast

	alpha-multiply
	qoi-on-pixel-received

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r


( 7 6 5 4 3 2 1 0 | 7 6 5 4 3 2 1 0 )
( 0 1| diff green |  dr-rg | db-dg  )
@qoi-chunk-luma ( {buffer}* -- )
	LDA 
	DUP #04 SFT 
	[ ;&dg LDA ] ADD #28 SUB
	;qoi-last/r LDA ADD
	
	[ ;&dg LDA ] #20 SUB
	;qoi-last/g LDA ADD

	ROT #0f AND
	[ ;&dg LDA ] ADD #28 SUB
	;qoi-last/b LDA ADD

	;qoi-last/a LDA

	qoi-stindex
	Mqoi-stlast

	alpha-multiply
	qoi-on-pixel-received

	;qoi-chunk set-on-bytes-received
	#0001 set-bytes-expected
	JMP2r
&dg $1


@qoi-on-pixel-received ( r g b -- )
	[ ,qoi-is-linear LDR ] ?{
		srgb-to-linear
	}
	[ LIT2 &routine $2 ] JMP2


@qoi-is-linear $1


( misc. )


@handle-image-size ( w* h* -- )
	;str/height print-str DUP2 Mprint-short Mendl

	DUP2 .Screen/height DEO2 .img-h STZ2

	;str/width print-str DUP2 Mprint-short Mendl

	DUP2 .Screen/width DEO2 .img-w STZ2
	JMP2r


@prepare-palette-builtin ( -- )
	.current-palette LDZ2 
	          LDA2k .color0/g STZ .color0/r STZ
	INC2 INC2 LDA2k .color1/r STZ .color0/b STZ
	INC2 INC2 LDA2k .color1/b STZ .color1/g STZ
	INC2 INC2 LDA2k .color2/g STZ .color2/r STZ
	INC2 INC2 LDA2k .color3/r STZ .color2/b STZ
	INC2 INC2 LDA2  .color3/b STZ .color3/g STZ
	( fallthrough )


@prepare-palette ( -- )
	.color0/r LDZ linear-to-srgb-single #f0 AND
	.color1/r LDZ linear-to-srgb-single #04 SFT ORA
	.color2/r LDZ linear-to-srgb-single #f0 AND
	.color3/r LDZ linear-to-srgb-single #04 SFT ORA
	.System/r DEO2

	.color0/g LDZ linear-to-srgb-single #f0 AND
	.color1/g LDZ linear-to-srgb-single #04 SFT ORA
	.color2/g LDZ linear-to-srgb-single #f0 AND
	.color3/g LDZ linear-to-srgb-single #04 SFT ORA
	.System/g DEO2

	.color0/b LDZ linear-to-srgb-single #f0 AND
	.color1/b LDZ linear-to-srgb-single #04 SFT ORA
	.color2/b LDZ linear-to-srgb-single #f0 AND
	.color3/b LDZ linear-to-srgb-single #04 SFT ORA
	.System/b DEO2
	JMP2r


( @pixel-to-4bit ( r8 g8 b8 -- r g b ) )
( 	ROT DUP #f0 LTH ?{ POP #0f !&g } #08 ADD #04 SFT )
( 	&g )
( 	ROT DUP #f0 LTH ?{ POP #0f !&b } #08 ADD #04 SFT )
( 	&b )
( 	ROT DUP #f0 LTH ?{ POP #0f JMP2r } #08 ADD #04 SFT )
( 	JMP2r )


( 6-bit linear RGB is used for color partitions )
@rgb-to-rgb6 ( r g b -- r6 g6 b6 )
	ROT #02 SFT
	ROT #02 SFT
	ROT #02 SFT
	JMP2r




( image processing )


( 8-bit sRGB triplet to 8-bit linear RGB triplet )
@srgb-to-linear ( sr sg sb -- r g b )
	ROT #00 SWP ;&lut ADD2 LDA
	ROT #00 SWP ;&lut ADD2 LDA
	ROT #00 SWP ;&lut ADD2 LDA
	JMP2r	
&lut [
	00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 01 
	01 01 02 02 02 02 02 02 02 02 03 03 03 03 03 03 
	04 04 04 04 04 05 05 05 05 06 06 06 06 07 07 07 
	08 08 08 08 09 09 09 0a 0a 0a 0b 0b 0c 0c 0c 0d 
	0d 0d 0e 0e 0f 0f 10 10 11 11 11 12 12 13 13 14 
	14 15 16 16 17 17 18 18 19 19 1a 1b 1b 1c 1d 1d 
	1e 1e 1f 20 20 21 22 23 23 24 25 25 26 27 28 29 
	29 2a 2b 2c 2d 2d 2e 2f 30 31 32 33 33 34 35 36 
	37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 
	47 48 49 4a 4c 4d 4e 4f 50 51 52 54 55 56 57 58 
	5a 5b 5c 5d 5f 60 61 63 64 65 67 68 69 6b 6c 6d 
	6f 70 72 73 74 76 77 79 7a 7c 7d 7f 80 82 83 85 
	86 88 8a 8b 8d 8e 90 92 93 95 97 98 9a 9c 9d 9f 
	a1 a3 a4 a6 a8 aa ab ad af b1 b3 b5 b7 b8 ba bc 
	be c0 c2 c4 c6 c8 ca cc ce d0 d2 d4 d6 d8 da dc 
	de e0 e2 e5 e7 e9 eb ed ef f2 f4 f6 f8 fa fd ff 
]

( single 8-bit linear RGB value to 8-bit sRGB value )
@linear-to-srgb-single ( scolor -- color )
	#00 SWP ;&lut ADD2 LDA
	JMP2r	
&lut [
	00 0d 16 1c 22 26 2a 2e 32 35 38 3b 3d 40 42 45 
	47 49 4b 4d 4f 51 53 55 56 58 5a 5c 5d 5f 60 62 
	63 65 66 68 69 6a 6c 6d 6e 70 71 72 73 75 76 77 
	78 79 7a 7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 
	89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 94 95 96 97 
	98 99 9a 9b 9b 9c 9d 9e 9f 9f a0 a1 a2 a3 a3 a4 
	a5 a6 a7 a7 a8 a9 aa aa ab ac ad ad ae af af b0 
	b1 b2 b2 b3 b4 b4 b5 b6 b6 b7 b8 b9 b9 ba bb bb 
	bc bd bd be be bf c0 c0 c1 c2 c2 c3 c4 c4 c5 c5 
	c6 c7 c7 c8 c8 c9 ca ca cb cb cc cd cd ce ce cf 
	d0 d0 d1 d1 d2 d2 d3 d4 d4 d5 d5 d6 d6 d7 d7 d8 
	d8 d9 da da db db dc dc dd dd de de df df e0 e0 
	e1 e2 e2 e3 e3 e4 e4 e5 e5 e6 e6 e7 e7 e8 e8 e9 
	e9 ea ea eb eb ec ec ed ed ee ee ee ef ef f0 f0 
	f1 f1 f2 f2 f3 f3 f4 f4 f5 f5 f6 f6 f6 f7 f7 f8 
	f8 f9 f9 fa fa fb fb fb fc fc fd fd fe fe ff ff
]


( partitioning color space, via median cut algorithm )

( see bottom of file for partition structure )
%Mpart-sort-buffer-size { #0100 } 
%Mpart-sort-buffers-size { #0300 } 
%Mpart-size { #030a } 
%Mpart-max-color { #3f }


@part-debug ( part -- )
	#00 OVR Mpart-size MUL2 STH2
	( { "part 20 00 } STH2r print-str DUP print-byte Mcout )
	LIT "R Mcout ;part/r-beg Msk+ LDA2 
	SWP print-byte LIT "- Mcout print-byte LIT ", Mcout
	LIT "G Mcout ;part/g-beg Msk+ LDA2
	SWP print-byte LIT "- Mcout print-byte LIT ", Mcout
	LIT "B Mcout ;part/b-beg Msk+ LDA2
	SWP print-byte LIT "- Mcout print-byte Mendl

	.part-split-step LDZ INC LTH ?{ POP2r JMP2r }

	LIT "C Mcout ;part/count Msk+ 
	LDA2k Mprint-short INC2 INC2 LDA2 Mprint-short Mendl

	#0000 
	LIT "S Mcout LIT "R Mcout Mendl
	&loopr
		DUP2 #02 SFT2 NIP
		print-byte LIT "| Mcout
		DUP2 ;part/r-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/r-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 
		DUP #40 SFT ?{ Mendl !&end-print-r }
		#20 Mcout
		&end-print-r
		Mpart-sort-buffer-size NEQ2
	?&loopr

	POP2 #0000 
	LIT "S Mcout LIT "G Mcout Mendl
	&loopg
		DUP2 #02 SFT2 NIP
		print-byte LIT "| Mcout
		DUP2 ;part/g-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/g-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 
		DUP #40 SFT ?{ Mendl !&end-print-g }
		#20 Mcout
		&end-print-g
		Mpart-sort-buffer-size NEQ2
	?&loopg

	#0000 
	LIT "S Mcout LIT "B Mcout Mendl
	&loopb
		DUP2 #02 SFT2 NIP
		print-byte LIT "| Mcout
		DUP2 ;part/b-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/b-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 
		DUP #40 SFT ?{ Mendl !&end-print-b }
		#20 Mcout
		&end-print-b
		Mpart-sort-buffer-size NEQ2
	?&loopb
	POP2
	Mendl POP2r
	JMP2r


@part-init ( part -- )
	#00 SWP Mpart-size MUL2 STH2
	#0000 ;part/count Msk+ STA2k
	INC2 INC2 STA2
	#0000 
	&loop
		#0000 OVR2 ;part/r-sort ADD2 Msk+ STA2
		INC2 INC2 DUP2 Mpart-sort-buffers-size NEQ2
	?&loop
	POP2 POP2r
	JMP2r


@part-add-pixel ( r6 g6 b6 part -- )
	#00 SWP Mpart-size MUL2 STH2
	#00 SWP #20 SFT2 ;part/b-sort Msk+ ADD2 inc32-addr
	#00 SWP #20 SFT2 ;part/g-sort Msk+ ADD2 inc32-addr
	#00 SWP #20 SFT2 ;part/r-sort Msk+ ADD2 inc32-addr
	;part/count Ms+ 
	!inc32-addr


( get color variation within partition )
@part-get-max-var ( part -- max-var-chan max-var )
	#00 SWP Mpart-size MUL2 
	STH2
	;part/count Msk+ Mload32
	non-zero32 ?{ POP2r #0000 JMP2r }


	( order of preference:
	  if green has equal variation to red or blue, prefer green
	  if red has equal variation to blue, prefer red )
	( we will ignore values less than 1/16 of max value )
	%Mpart-var-filter { #04 }

	LIT "G Mcout 

	( find max value )
	#0000 DUP2 [ ,&g-max-h STR2 ] [ ,&g-max-l STR2 ]
	;part/g-beg Msk+ LDA
	&find-g-max
		#00 OVR #20 SFT ;part/g-sort ADD2 Msk+ Mload32 
		OVR2 OVR2
		[ ,&g-max-h LDR2 ] [ ,&g-max-l LDR2 ]
		( index valh* vall* valh* vall* maxh* maxl* )
		lt32 ?{ [ ,&g-max-l STR2 ] [ ,&g-max-h STR2 ] !&g-max }
		POP2 POP2
		&g-max
		INC
		DUP ;part/g-end Msk+ LDA NEQ ?{ !&found-g-max }
	!&find-g-max
	[ &g-max-h $2 &g-max-l $2 ]
	&found-g-max
	POP
	[ ,&g-max-h LDR2 ] [ ,&g-max-l LDR2 ] 
	LIT "M Mdebug32
	Mpart-var-filter rshift32 
	LIT "> Mdebug32
	[ ,&g-max-l STR2 ] [ ,&g-max-h STR2 ]

	( find index of first non-zero element )
	;part/g-beg Msk+ LDA
	&find-g-beg
		#00 OVR #20 SFT ;part/g-sort ADD2 Msk+ Mload32 
		[ ,&g-max-h LDR2 ] [ ,&g-max-l LDR2 ]
		gteq32 ?&found-g-beg
		INC
	!&find-g-beg
	&found-g-beg
	LIT "B Mdebug-byte

	( find index of last non-zero element )
	;part/g-end Msk+ LDA #01 SUB
	&find-g-end
		#00 OVR #20 SFT ;part/g-sort ADD2 Msk+ Mload32 
		;&g-max-h LDA2 ;&g-max-l LDA2
		gteq32 ?&found-g-end
		#01 SUB
	!&find-g-end
	&found-g-end
	LIT "E Mdebug-byte
	SWP SUB
	LIT "V Mdebug-byte Mendl


	LIT "R Mcout 

	( find max value )
	#0000 DUP2 [ ,&r-max-h STR2 ] [ ,&r-max-l STR2 ]
	;part/r-beg Msk+ LDA
	&find-r-max
		#00 OVR #20 SFT ;part/r-sort ADD2 Msk+ Mload32 
		OVR2 OVR2
		[ ,&r-max-h LDR2 ] [ ,&r-max-l LDR2 ]
		( index valh* vall* valh* vall* maxh* maxl* )
		lt32 ?{ [ ,&r-max-l STR2 ] [ ,&r-max-h STR2 ] !&r-max }
		POP2 POP2
		&r-max
		INC
		DUP ;part/r-end Msk+ LDA NEQ ?{ !&found-r-max }
	!&find-r-max
	[ &r-max-h $2 &r-max-l $2 ]
	&found-r-max
	POP
	[ ,&r-max-h LDR2 ] [ ,&r-max-l LDR2 ] 
	LIT "M Mdebug32
	Mpart-var-filter rshift32 
	LIT "> Mdebug32
	[ ,&r-max-l STR2 ] [ ,&r-max-h STR2 ]

	( find index of first non-zero element )
	;part/r-beg Msk+ LDA
	&find-r-beg
		#00 OVR #20 SFT ;part/r-sort ADD2 Msk+ Mload32 
		[ ,&r-max-h LDR2 ] [ ,&r-max-l LDR2 ]
		gteq32 ?&found-r-beg
		INC
	!&find-r-beg
	&found-r-beg
	LIT "B Mdebug-byte

	( find index of last non-zero element )
	;part/r-end Msk+ LDA #01 SUB
	&find-r-end
		#00 OVR #20 SFT ;part/r-sort ADD2 Msk+ Mload32 
		;&r-max-h LDA2 ;&r-max-l LDA2
		gteq32 ?&found-r-end
		#01 SUB
	!&find-r-end
	&found-r-end
	LIT "E Mdebug-byte
	SWP SUB
	LIT "V Mdebug-byte Mendl


	LIT "B Mcout 

	( find max value )
	#0000 DUP2 [ ,&b-max-h STR2 ] [ ,&b-max-l STR2 ]
	;part/b-beg Msk+ LDA
	&find-b-max
		#00 OVR #20 SFT ;part/b-sort ADD2 Msk+ Mload32 
		OVR2 OVR2
		[ ,&b-max-h LDR2 ] [ ,&b-max-l LDR2 ]
		( index valh* vall* valh* vall* maxh* maxl* )
		lt32 ?{ [ ,&b-max-l STR2 ] [ ,&b-max-h STR2 ] !&b-max }
		POP2 POP2
		&b-max
		INC
		DUP ;part/b-end Msk+ LDA NEQ ?{ !&found-b-max }
	!&find-b-max
	[ &b-max-h $2 &b-max-l $2 ]
	&found-b-max
	POP
	[ ,&b-max-h LDR2 ] [ ,&b-max-l LDR2 ] 
	LIT "M Mdebug32
	Mpart-var-filter rshift32 
	LIT "> Mdebug32
	[ ,&b-max-l STR2 ] [ ,&b-max-h STR2 ]

	( find index of first non-zero element )
	;part/b-beg Msk+ LDA
	&find-b-beg
		#00 OVR #20 SFT ;part/b-sort ADD2 Msk+ Mload32 
		[ ,&b-max-h LDR2 ] [ ,&b-max-l LDR2 ]
		gteq32 ?&found-b-beg
		INC
	!&find-b-beg
	&found-b-beg
	LIT "B Mdebug-byte

	( find index of last non-zero element )
	;part/b-end Msk+ LDA #01 SUB
	&find-b-end
		#00 OVR #20 SFT ;part/b-sort ADD2 Msk+ Mload32 
		;&b-max-h LDA2 ;&b-max-l LDA2
		gteq32 ?&found-b-end
		#01 SUB
	!&find-b-end
	&found-b-end
	LIT "E Mdebug-byte
	SWP SUB
	LIT "V Mdebug-byte Mendl
	Mendl


	POP2r

	Mb STH
	( wst: gvar rvar max-var | rst: max-var-chan )
	LTHk ?{ POPr Mr STH SWP } NIP 
	( wst: gvar max-var | rst: max-var-chan )
	LTHk ?{ POPr Mg STH SWP } NIP 
	
	STHr SWP
	JMP2r


@part-get-median ( {sorted}* {count}* -- median )
	LDA2k SWP2 INC2 INC2 LDA2 #01 shift32-0
	[ ,&halfl STR2 ] [ ,&halfh STR2 ]
	DUP2 #0000 DUP2 ROT2

	( sum the sorted pixel values )
	( iterate until sum is half of all values )
	&loop ( buffer* sumh* suml* ptr* )
		STH2k Mload32
		add32
		OVR2 OVR2
		[ LIT2 &halfh 0000 LIT2 &halfl 0000 ] lt32 ?{ 
			( correction for when first half has
			  too few colors )
			( load current val again )
			STH2kr Mload32 
			sub32
			[ ,&halfh LDR2 ] [ ,&halfl LDR2 ] #01 rshift32
			gteq32 ?{
				( previous half had less than 1/4th )
				STH2r
				SWP2 SUB2
				#02 SFT2 NIP
				DUP #0f EQU ?{ INC }
				JMP2r
			}
			STH2r
			SWP2 SUB2
			#02 SFT2 NIP
			JMP2r
		}
		STH2r #0004 ADD2
	!&loop


@get-partition-optimize
	#00 ;get-partition/check0 STA

	.part-split-step LDZ
	DUP #00 EQU ?{
		#01 ;get-partition/check0 STA

		;part/r-beg LDA ;get-partition/part0-r-beg STA
		;part/g-beg LDA ;get-partition/part0-g-beg STA
		;part/b-beg LDA ;get-partition/part0-b-beg STA
		;part/r-end LDA ;get-partition/part0-r-end STA
		;part/g-end LDA ;get-partition/part0-g-end STA
		;part/b-end LDA ;get-partition/part0-b-end STA

		#00 ;get-partition/check1 STA
	}
	DUP #02 LTH ?{
		#01 ;get-partition/check1 STA

		;part1/r-beg LDA ;get-partition/part1-r-beg STA
		;part1/g-beg LDA ;get-partition/part1-g-beg STA
		;part1/b-beg LDA ;get-partition/part1-b-beg STA
		;part1/r-end LDA ;get-partition/part1-r-end STA
		;part1/g-end LDA ;get-partition/part1-g-end STA
		;part1/b-end LDA ;get-partition/part1-b-end STA

		#00 ;get-partition/check2 STA
	}
	#03 LTH ?{ 
		#01 ;get-partition/check2 STA

		;part2/r-beg LDA ;get-partition/part2-r-beg STA
		;part2/g-beg LDA ;get-partition/part2-g-beg STA
		;part2/b-beg LDA ;get-partition/part2-b-beg STA
		;part2/r-end LDA ;get-partition/part2-r-end STA
		;part2/g-end LDA ;get-partition/part2-g-end STA
		;part2/b-end LDA ;get-partition/part2-b-end STA
	}
	JMP2r


@get-partition ( r g b -- r g b part )
	[ LIT &check0 $1 ] ?{ #00 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part0-r-beg $1 ] LTH ?{ !&r0 } POP2 POP !&part1
	&r0 [ LIT &part0-r-end $1 ] LTH ?{ POP2 !&part1 }

	DUP [ LIT &part0-b-beg $1 ] LTH ?{ !&b0 } POP2 !&part1
	&b0 [ LIT &part0-b-end $1 ] LTH ?{ POP !&part1 }

	DUP [ LIT &part0-g-beg $1 ] LTH ?{ !&g0 } POP !&part1
	&g0 [ LIT &part0-g-end $1 ] LTH ?{ !&part1 }
	#00 JMP2r

	&part1
	[ LIT &check1 $1 ] ?{ #01 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part1-r-beg $1 ] LTH ?{ !&r1 } POP2 POP !&part2
	&r1 [ LIT &part1-r-end $1 ] LTH ?{ POP2 !&part2 }

	DUP [ LIT &part1-b-beg $1 ] LTH ?{ !&b1 } POP2 !&part2
	&b1 [ LIT &part1-b-end $1 ] LTH ?{ POP !&part2 }

	DUP [ LIT &part1-g-beg $1 ] LTH ?{ !&g1 } POP !&part2
	&g1 [ LIT &part1-g-end $1 ] LTH ?{ !&part2 }
	#01 JMP2r

	&part2
	[ LIT &check2 $1 ] ?{ #02 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part2-r-beg $1 ] LTH ?{ !&r2 } POP2 POP !&part3
	&r2 [ LIT &part2-r-end $1 ] LTH ?{ POP2 !&part3 }

	DUP [ LIT &part2-b-beg $1 ] LTH ?{ !&b2 } POP2 !&part3
	&b2 [ LIT &part2-b-end $1 ] LTH ?{ POP !&part3 }

	DUP [ LIT &part2-g-beg $1 ] LTH ?{ !&g2 } POP !&part3
	&g2 [ LIT &part2-g-end $1 ] LTH ?{ !&part3 }
	#02 JMP2r

	&part3
	( LIT "3 Mdebug-rgb Mendl )
	#03
	JMP2r


@palette-split-init ( -> )
	get-partition-optimize

	#00 part-init
	.part-split-step LDZ DUP ?{
		Mpart-max-color INC ;part/r-end STA
		Mpart-max-color INC ;part/g-end STA
		Mpart-max-color INC ;part/b-end STA
	}
	DUP #00 EQU ?{
		#01 part-init 
		#02 LTH ?{
			#02 part-init
		}
	}

	;palette-split set-on-pixel-received
	;palette-split-end set-on-file-end
	;read-file .Screen/vector DEO2
	BRK


@palette-split ( r8 g8 b8 -- )
	( LIT "P Mdebug-rgb )
	rgb-to-rgb6
	get-partition
	( LIT "R Mdebug-byte Mendl )
	DUP ?{
		!part-add-pixel ( 0 )
	}
	#01 GTHk ?{
		POP
		!part-add-pixel ( 1 )
	}
	POP
	#02 NEQk ?{
		POP
		!part-add-pixel ( 2 )
	} 
	POP
	!part-add-pixel


@palette-split-end ( -> )
	Mendl Mendl Mendl
	#00 part-debug
	#01 part-debug
	#02 part-debug
	#03 part-debug

	( find partition with largest color variation )

	#0000 part-get-max-var
	LIT "V Mdebug-short Mendl
	( max-var-part max-var-chan max-var )
	.part-split-step LDZ ?{ !&found-max-var }
	#01 part-get-max-var 
	LIT "V Mdebug-short Mendl
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #01 STH2r !&part2-var
	}
	NIP NIP
	&part2-var
	.part-split-step LDZ #01 GTH ?{ !&found-max-var }
	#02 part-get-max-var 
	LIT "V Mdebug-short Mendl
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #02 STH2r !&part3-var
	}
	NIP NIP
	&part3-var
	.part-split-step LDZ #02 GTH ?{ !&found-max-var }
	#03 part-get-max-var 
	LIT "V Mdebug-short Mendl
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #03 STH2r !&found-max-var
	}
	NIP NIP
	&found-max-var
	POP

	( split partition )

	DUP Mr NEQ ?{
		POP
		LIT "P Mdebug-byte Mendl
		.part-split-step LDZ INC
		#00 SWP Mpart-size MUL2 STH2
		#00 SWP Mpart-size MUL2 STH2
		( rst: dest-part-offset* src-part-offset* )

		;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r
		;part/r-sort Msk+ ;part/count Msk+ part-get-median DUP 
		;part/r-end Msk+ STA SWP2r ;part/r-beg Msk+ STA SWP2r

		;part/g-beg Msk+ LDA SWP2r ;part/g-beg Msk+ STA SWP2r
		;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r

		;part/b-beg Msk+ LDA SWP2r ;part/b-beg Msk+ STA SWP2r
		;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
		!&split-done
	}
	DUP Mg NEQ ?{
		POP
		LIT "P Mdebug-byte Mendl
		.part-split-step LDZ INC
		#00 SWP Mpart-size MUL2 STH2
		#00 SWP Mpart-size MUL2 STH2
		( rst: dest-part-offset* src-part-offset* )

		;part/r-beg Msk+ LDA SWP2r ;part/r-beg Msk+ STA SWP2r
		;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r

		;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r
		;part/g-sort Msk+ ;part/count Msk+ part-get-median DUP 
		;part/g-end Msk+ STA SWP2r ;part/g-beg Msk+ STA SWP2r

		;part/b-beg Msk+ LDA SWP2r ;part/b-beg Msk+ STA SWP2r
		;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
		!&split-done
	}
	POP
	LIT "P Mdebug-byte Mendl
	.part-split-step LDZ INC
	#00 SWP Mpart-size MUL2 STH2
	#00 SWP Mpart-size MUL2 STH2
	( rst: dest-part-offset* src-part-offset* )

	;part/r-beg Msk+ LDA SWP2r ;part/r-beg Msk+ STA SWP2r
	;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r

	;part/g-beg Msk+ LDA SWP2r ;part/g-beg Msk+ STA SWP2r
	;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r

	;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
	;part/b-sort Msk+ ;part/count Msk+ part-get-median DUP 
	;part/b-end Msk+ STA SWP2r ;part/b-beg Msk+ STA SWP2r

	&split-done
	POP2r POP2r

	.part-split-step LDZ ?{
		[ LIT2 01 -part-split-step ] STZ
		!palette-split-init
	}
	.part-split-step LDZ [ #01 ] NEQ ?{
		[ LIT2 02 -part-split-step ] STZ
		!palette-split-init
	}
	[ LIT2 03 -part-split-step ] STZ
	( fallthrough )


@sum-colors-init ( -- )
	#00 part-init
	#01 part-init
	#02 part-init
	#03 part-init
	get-partition-optimize

	;palette-split set-on-pixel-received
	;avg-colors set-on-file-end
	;read-file .Screen/vector DEO2
	JMP2r



@avg-color ( {chan}* {n}* -- avg-color )
	STH2 STH2
	#0000 DUP2k
	( sum** index* | {n}* {chan}* )
	&loop
		DUP2 #20 SFT2 Msk+ ( count addr for index )
		SWP2 STH2
		LDA2k SWP2 INC2 INC2 LDA2 ( load 32-bit count )
		#0000 STH2kr mul32 ( multiply by index )
		add32
		STH2r INC2
		DUP2 #00 Mpart-max-color INC NEQ2 ?{
			POP2 POP2r
			( sum** | {n}* )
			STH2r
			LDA2k SWP2 INC2 INC2 LDA2
			div32
			( clear high 24 bits and check they're zero )
			SWP2 #0000 EQU2 ?{ !fail }
			SWP #00 EQU ?{ !fail }
			JMP2r
		}
	!&loop


@avg-colors ( -> )
	#00 part-debug
	#01 part-debug
	#02 part-debug
	#03 part-debug

	;part/r-sort ;part/count avg-color ;&color0r STA
	;part/g-sort ;part/count avg-color ;&color0g STA
	;part/b-sort ;part/count avg-color ;&color0b STA

	;part1/r-sort ;part1/count avg-color ;&color1r STA
	;part1/g-sort ;part1/count avg-color ;&color1g STA
	;part1/b-sort ;part1/count avg-color ;&color1b STA

	;part2/r-sort ;part2/count avg-color ;&color2r STA
	;part2/g-sort ;part2/count avg-color ;&color2g STA
	;part2/b-sort ;part2/count avg-color ;&color2b STA

	;part3/r-sort ;part3/count avg-color ;&color3r STA
	;part3/g-sort ;part3/count avg-color ;&color3g STA
	;part3/b-sort ;part3/count avg-color ;&color3b STA

	prepare-palette-avg
	!display-init
&color0r $1 &color0g $1 &color0b $1
&color1r $1 &color1g $1 &color1b $1
&color2r $1 &color2g $1 &color2b $1
&color3r $1 &color3g $1 &color3b $1


@prepare-palette-avg ( -- )
	;avg-colors/color0r LDA #20 SFT .color0/r STZ
	;avg-colors/color1r LDA #20 SFT .color1/r STZ
	;avg-colors/color2r LDA #20 SFT .color2/r STZ
	;avg-colors/color3r LDA #20 SFT .color3/r STZ

	;avg-colors/color0g LDA #20 SFT .color0/g STZ
	;avg-colors/color1g LDA #20 SFT .color1/g STZ
	;avg-colors/color2g LDA #20 SFT .color2/g STZ
	;avg-colors/color3g LDA #20 SFT .color3/g STZ

	;avg-colors/color0b LDA #20 SFT .color0/b STZ
	;avg-colors/color1b LDA #20 SFT .color1/b STZ
	;avg-colors/color2b LDA #20 SFT .color2/b STZ
	;avg-colors/color3b LDA #20 SFT .color3/b STZ
	!prepare-palette



( displaying )


@display-init ( -> )
	.color0/r LDZ LIT "R Mdebug-byte #01 SFT 
	DUP .color0-7/r STZ
	#01 SFT ;pick-color/color0r STA
	.color0/g LDZ LIT "G Mdebug-byte #01 SFT 
	DUP .color0-7/g STZ
	#01 SFT ;pick-color/color0g STA
	.color0/b LDZ LIT "B Mdebug-byte #01 SFT 
	DUP .color0-7/b STZ
	#01 SFT ;pick-color/color0b STA
	Mendl

	.color1/r LDZ LIT "R Mdebug-byte #01 SFT 
	DUP .color1-7/r STZ
	#01 SFT ;pick-color/color1r STA
	.color1/g LDZ LIT "G Mdebug-byte #01 SFT 
	DUP .color1-7/g STZ
	#01 SFT ;pick-color/color1g STA
	.color1/b LDZ LIT "B Mdebug-byte #01 SFT 
	DUP .color1-7/b STZ
	#01 SFT ;pick-color/color1b STA
	Mendl

	.color2/r LDZ LIT "R Mdebug-byte #01 SFT 
	DUP .color2-7/r STZ
	#01 SFT ;pick-color/color2r STA
	.color2/g LDZ LIT "G Mdebug-byte #01 SFT 
	DUP .color2-7/g STZ
	#01 SFT ;pick-color/color2g STA
	.color2/b LDZ LIT "B Mdebug-byte #01 SFT 
	DUP .color2-7/b STZ
	#01 SFT ;pick-color/color2b STA
	Mendl

	.color3/r LDZ LIT "R Mdebug-byte #01 SFT 
	DUP .color3-7/r STZ
	#01 SFT ;pick-color/color3r STA
	.color3/g LDZ LIT "G Mdebug-byte #01 SFT 
	DUP .color3-7/g STZ
	#01 SFT ;pick-color/color3g STA
	.color3/b LDZ LIT "B Mdebug-byte #01 SFT 
	DUP .color3-7/b STZ
	#01 SFT ;pick-color/color3b STA
	Mendl

	Mmode-no-dithering is-mode ?{
		( ;display-nop .on-pixel-received STZ2 )
		;display-dither set-on-pixel-received
		( ;display .on-pixel-received STZ2 )
		!&display-func-set
	}
	;display set-on-pixel-received
	&display-func-set

	;done set-on-file-end
	.current-mode LDZ Mmode-streaming AND ?{
		;read-file .Screen/vector DEO2
	}

	[ LIT2 01 -Screen/auto ] DEO
	#0000 .Screen/x DEO2
	#0000 .Screen/y DEO2

	#0000
	&clear-buf
		#0000 OVR2 ;dither-buffer/r ADD2 STA2
		#0000 OVR2 ;dither-buffer/g ADD2 STA2
		#0000 OVR2 ;dither-buffer/b ADD2 STA2
		INC2 INC2
		DUP2 .img-w LDZ2 LTH2
	?&clear-buf
	POP2
	
	.current-palette LDZ2 ;palettes/detected-from-img EQU2 ?{
		;pick-color ;display/get-color-func STA2
		;pick-color ;display-dither/get-color-func STA2
		BRK
	}
	Mmode-partition-color-func is-mode ?{
		;pick-color ;display/get-color-func STA2
		;pick-color ;display-dither/get-color-func STA2
		BRK
	}
	;get-partition ;display/get-color-func STA2
	;get-partition ;display-dither/get-color-func STA2
	BRK


@display ( r8 g8 b8 -- )
	rgb-to-rgb6
	[ LIT2 &get-color-func $2 ] JSR2
	.Screen/pixel DEO
	POP2 POP
	advance-screen-pos POP
	JMP2r


( sierra lite dithering )
( quantization error is pushed to the next pixel in line, and
  to two pixels on the next line )
(      X  1/2
  1/4 1/4     )
( we use only one line buffer, and overwrite values behind current x )
@display-dither ( r8 g8 b8 -- )
	( LIT "I Mdebug-rgb Mendl )
	( LIT "B Mcout )
	#01 SFT
	;dither-buffer/b .Screen/x DEI2 ADD2 LDA
	( LIT "B Mcout DUP print-sbyte )
	add8s-clamp-pos STH

	( r8 g8 | b-cor7 )
	#01 SFT
	;dither-buffer/g .Screen/x DEI2 ADD2 LDA 
	( LIT "G Mcout DUP print-sbyte )
	add8s-clamp-pos STH

	( r8 | b-cor7 g-cor7 )
	#01 SFT
	;dither-buffer/r .Screen/x DEI2 ADD2 LDA
	( LIT "R Mcout DUP print-sbyte )
	add8s-clamp-pos STH
	( Mendl )

	ROTkr 
	( | b-cor7 g-cor7 r-cor7 g-cor7 r-cor7 b-cor7 )
	STHr #01 SFT
	STHr #01 SFT SWP
	STHr #01 SFT SWP
	( LIT "C Mdebug-rgb Mendl )
	( r-cor6 g-cor6 b-cor6 | b-cor7 g-cor7 r-cor7 )
	[ LIT2 &get-color-func $2 ] JSR2
	( LIT "P Mdebug-byte Mendl )

	( LIT "R Mcout )
	( r-cor6 g-cor6 b-cor6 col | b-cor7 g-cor7 r-cor7 )
	STHr #01 SFT ( ... col r-cor-half7 )
	( LIT "C Mdebug-byte )
	OVR #03 MUL .color0/r ADD LDZ #02 SFT ( r-print-half7 )
	( LIT "P Mdebug-byte )
	SUB ( r-delta-halfS )
	( LIT "D Mcout DUP print-sbyte )
	;dither-buffer/r .Screen/x DEI2 ADD2 STH2k
	( r-delta-halfS addr* | addr* )
	INC2       LDA OVR ADD STH2kr INC2      STA  ( next x, add )
	               half8s  STH2kr           STAk ( cur x, write )
	#0001 SUB2 LDA ADD     STH2r #0001 SUB2 STA  ( prev x, add )
	( Mendl )

	( LIT "G Mcout )
	( r-cor6 g-cor6 b-cor6 col | b-cor7 g-cor7 )
	STHr #01 SFT ( ... col g-cor-half7 )
	( LIT "C Mdebug-byte )
	OVR #03 MUL .color0/g ADD LDZ #02 SFT ( g-print-half7 )
	( LIT "P Mdebug-byte )
	SUB ( g-delta-halfS )
	( LIT "D Mcout DUP print-sbyte )
	;dither-buffer/g .Screen/x DEI2 ADD2 STH2k
	( g-delta-halfS addr* | addr* )
	INC2       LDA OVR ADD STH2kr INC2      STA  ( next x, add )
	               half8s  STH2kr           STAk ( cur x, write )
	#0001 SUB2 LDA ADD     STH2r #0001 SUB2 STA  ( prev x, add )
	( Mendl )

	( LIT "B Mcout )
	( r-cor6 g-cor6 b-cor6 col | b-cor7 )
	STHr #01 SFT ( ... col b-cor-half7 )
	( LIT "C Mdebug-byte )
	OVR #03 MUL .color0/b ADD LDZ #02 SFT ( b-print-half7 )
	( LIT "P Mdebug-byte )
	SUB ( b-delta-halfS )
	( LIT "D Mcout DUP print-sbyte )
	;dither-buffer/b .Screen/x DEI2 ADD2 STH2k
	( b-delta-halfS addr* | addr* )
	INC2       LDA OVR ADD STH2kr INC2      STA  ( next x, add )
	               half8s  STH2kr           STAk ( cur x, write )
	#0001 SUB2 LDA ADD     STH2r #0001 SUB2 STA  ( prev x, add )
	( Mendl )

	.Screen/pixel DEO

	( Mendl )
	POP2 POP

	advance-screen-pos POP
	JMP2r


( chooses closest color from palette )
( probably the worst method for finding distance )
( r1-r0 + g1-g0 + b1-b0 )
@pick-color ( r6 g6 b6 -- r7 g7 b7 c )
	ROTk ( r g b g b r )
	[ LIT &color0r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color0b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color0g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #00 JMP2r }
	[ ,&diff0 STR ]

	ROTk ( r g b g b r )
	[ LIT &color1r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color1b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color1g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #01 JMP2r }
	[ ,&diff1 STR ]

	ROTk ( r g b g b r )
	[ LIT &color2r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color2b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color2g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #02 JMP2r }
	[ ,&diff2 STR ]

	ROTk ( r g b g b r )
	[ LIT &color3r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color3b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color3g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #03 JMP2r }

	#03 SWP
	( wst: cur-min-col cur-min )
	[ LIT &diff0 $1 ] LTHk ?{ NIP #00 SWP ROT } POP
	[ LIT &diff1 $1 ] LTHk ?{ NIP #01 SWP ROT } POP
	[ LIT &diff2 $1 ] LTH ?{ POP #02 }
	JMP2r


( assumes screen auto )
@advance-screen-pos ( -- new-line )
	.Screen/x DEI2 .img-w LDZ2 NEQ2 ?{
		#0000 .Screen/x DEO2 
		.Screen/y DEI2 
		( LIT "Y Mdebug-short Mendl )
		( DUP2 #0003 EQU2 ?done )
		INC2
		DUP2 .Screen/y DEO2
		.img-h LDZ2 NEQ2 ?{ 
			LIT ") Mcout Mendl
			POP2
			( #0000 .Screen/y DEO2  )
			( !stop-file-read )
			#01 
			JMP2r
		}
		#01 
		JMP2r
	}
	#00
	JMP2r




( end )


@done ( -- )
	( #80 .System/state DEO BRK )
	#0000 .Screen/vector DEO2
	;str/end print-str
	BRK



( errors )
	

@bad-file 
	;&str 
!fail-str
	&str "...Bad 20 "file 00


@too-large
	;&str 
!fail-str
	&str "...Too 20 "large 00


@fail-str ( error-msg* -> )
	print-str
( -> )
@fail ( -> )
	LIT "! Mcout
	[ LIT2 01 -System/state ] DEO
	BRK




( utils and stdlib )


@print-str ( str* -- )
	&while ( -- )
		LDAk .Console/write DEO
		INC2 LDAk 
	?&while
	POP2 
	JMP2r


@print-byte ( b -- )
	DUP #04 SFT DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO

	#0f AND DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO
	JMP2r


@inc32-addr ( addr* -- )
	DUP2 INC2 INC2 LDA2 INC2 ( inc lower short )
	DUP2 Mnon-zero2 ?{
		POP2 LDA2k INC2 OVR2 STA2 ( inc upper short )
		#0000 SWP2 INC2 INC2 STA2 
		JMP2r 
	}
	SWP2 INC2 INC2 STA2	
	JMP2r


( first operand must be positive, between #00 and #7f )
( result between #00 and #7f )
@add8s-clamp-pos ( b bs -- b )
	DUP #80 AND ?{
		( pos + pos )
		ADD
		DUP #80 AND ?{
			JMP2r
		} 
		( overflow )
		POP #7f JMP2r
	}
	( pos + neg )
	ADD
	DUP #80 AND ?{
		JMP2r
	} 
	( underflow )
	POP #00 JMP2r


( result between #00 and #ff, no overflow or underflow )
@add8s-clamp ( bs bs -- bs )
	OVR #80 AND ?{
		( pos + ? )
		DUP #80 AND ?{
			( pos + pos )
			ADD
			DUP #80 AND ?{
				JMP2r
			} 
			( overflow )
			POP #7f JMP2r
		}
		( neg + pos )
		ADD JMP2r
	}
	( ? + neg )
	OVR #80 AND ?{
		( neg + neg )
		ADD
		DUP #80 AND ?{
			( underflow )
			POP #80 JMP2r
		}
		JMP2r
	}
	( pos + neg )
	ADD JMP2r


@half8s ( sb -- sb )
	DUP #80 AND ?{ #01 SFT JMP2r }
	#ff SWP SUB #01 SFT #ff SWP SUB
	JMP2r


@print-sbyte ( sb -- )
	DUP #80 AND ?{ !print-byte }
	LIT "- Mcout #ff SWP SUB INC 
	!print-byte


@str-starts-with ( {str}* {prefix}* -- bool )
	STH2
	STH2
	#00
	&loop
		( index | prefix* str* )
		DUP
		#00 OVR Msk+ LDA
		SWP2r
		#00 ROT Msk+ LDA
		SWP2r
		DUP ?{
			POP2 POP POP2r POP2r #01 JMP2r
		}
		NEQ ?{ 
			INC !&loop
		}
		POP POP2r POP2r #00 JMP2r



( on monochrome screens, colors 0 and 2 are black, 1 and 3 are white )
@palettes [
	&bw    [ 00 00 00  ff ff ff  55 55 55  aa aa aa ]
	&darkb [ 00 00 88  ff ff ff  00 ff 00  ff 00 00 ]
	&bwrg  [ 00 00 00  ff ff ff  00 ff 00  ff 00 00 ]
	&bwrb  [ 00 00 00  ff ff ff  00 00 ff  ff 00 00 ]
	&bwbg  [ 00 00 00  ff ff ff  00 00 ff  00 ff 00 ]
	&color [ 00 00 00  aa ee ff  ee ff 00  ff 00 00 ]
	&detected-from-img ( special palette )
]


@str [
	&init "Hello! 0a 00
	&read "Reading 20 00
	&read-file "file: 20 00
	&read-stdin "standard 20 "input... 0a 00
	&end "Готово! 0a 00
	&usage "Usage: 20 "svitlyna.rom 20 "image.ff 0a 00
	&cannot-fullscreen "Unable 20 "to 20 "resize 20 "screen. 0a 00
	&width "w: 20 00
	&height "h: 20 00
	&after-end "Warning: 20 
	           "input 20 "after 20 "image 20 "end. 0a 00
	&filename-big "File 20 "name 20 "too 20 "big. 0a 00
	&io-error "I/O 20 "error 0a 20 00
	&memory-check "RAM 20 "check 20 "at 20 00
	&memory-error "Not 20 "enough 20 "RAM 0a 20 00
]



( http://plastic-idolatry.com/erik/nxu/math32.tal )


@bitcount16 ( x* -> n^ )
    LITr 00 &loop ORAk ?{ POP2 STHr JMP2r } #01 SFT2 INCr !&loop

@bitcount32 ( x** -> n^ )
    SWP2 bitcount16 DUP ?{ POP !bitcount16 } #10 NIP2 ADD JMP2r

( x != 0 )
@non-zero32 ( x** -> bool^ )
    ORA2 ORA JMP2r

( x + y )
@add32 ( xhi* xlo* yhi* ylo* -> zhi* zlo* )
    ROT2 STH2k ADD2 STH2k ROT2 ROT2 GTH2r #00 STHr ADD2 ADD2 SWP2 JMP2r

( x - y )
@sub32 ( x** y** -> z** )
    ROT2 STH2k SWP2 SUB2 STH2k ROT2 ROT2 LTH2r #00 STHr ADD2 SUB2 SWP2 JMP2r

( 16-bit multiplication )
@mul16 ( x* y* -> z** )
    ,&y1 STR ,&y0 STR ( save ylo, yhi )
    ,&x1 STR ,&x0 STR ( save xlo, xhi )
    #0000 ,&z1 STR ,&w0 STR ( reset z1 and w0 )

    ( x1 * y1 => z1z2 )
    LIT2 00 [ &x1 $1 ] LIT2 00 [ &y1 $1 ] MUL2 ,&z3 STR ,&z2 STR

    ( x0 * y1 => z0z1 )
    LIT2 00 _&x0 LDR LIT2 00 _&y1 LDR MUL2 ,&z1 LDR2 ADD2 ,&z1 STR2

    ( x1 * y0 => w1w2 )
    LIT2 00 _&x1 LDR LIT2 00 _&y0 LDR MUL2 ,&w2 STR ,&w1 STR

    ( x0 * y0 => w0w1 )
    LIT2 00 [ &x0 $1 ] LIT2 00 [ &y0 $1 ] MUL2 ,&w0 LDR2 ADD2 ,&w0 STR2

    ( add z and a<<8 )
    #00 LIT2 [ &z1 $1 &z2 $1 ] LIT [ &z3 $1 ]
    LIT2 [ &w0 $1 &w1 $1 ] LIT [ &w2 $1 ] #00
    !add32

( x * y )
@mul32 ( x** y** -> z** )
    ROT2k ( x0* x1* y0* y1* y0* y1* x1* )
    mul16 ,&z1 STR2 ,&z0 STR2 POP2 ( x0* x1* y0* y1* ; sum = [x1*y1] )
    STH2 ROT2 STH2                 ( x1* y0* [y1* x0*] )
    MUL2r MUL2 STH2r ADD2          ( x1*y0+y1*x0* )
    ( [x0*y0]<<32 will completely overflow )
    LIT2 [ &z0 $2 ] ADD2 ( sum += [x0*y1+x1*y0]<<16 )
    LIT2 [ &z1 $2 ] JMP2r

( x >> n )
@rshift32 ( x** n^ -> x>>n )
    DUP #08 LTH ?shift32-0 ( x n )
    DUP #10 LTH ?rshift32-1 ( x n )
    DUP #18 LTH ?rshift32-2 ( x n )
    !rshift32-3 ( x n )

( shift by 0-7 bits; used by both lshift and rshift )
@shift32-0 ( x** n^ -> x>>n )
    STH DUP2 STHkr SFT2                       ,&z2 STR2
    POP DUP2 STHkr SFT2 ,&z2 LDR ORA ,&z2 STR ,&z1 STR
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    LIT [ &z1 $1 ] LIT2 [ &z2 $2 ] JMP2r

( x << n )
@lshift32 ( x** n^ -> x<<n )
    DUP #08 LTH ?lshift32-0 ( x n )
    DUP #10 LTH ?lshift32-1 ( x n )
    DUP #18 LTH ?lshift32-2 ( x n )
    !lshift32-3 ( x n )

( shift right by 8-15 bits )
@rshift32-1 ( x** n^ -> x>>n )
    #08 SUB STH                 ( stash [n>>8] )
    POP DUP2 STHkr SFT2 ,&z2 STR2
    POP      STHr  SFT2 ,&z2 LDR ORA ,&z2 STR
    #00 SWP LIT2 [ &z2 $2 ] JMP2r

( shift right by 16-23 bits )
@rshift32-2 ( x** n^ -> x>>n )
    #10 SUB STH                 ( stash [n>>16] )
    POP2 STHr SFT2 #0000 SWP2 JMP2r

( shift right by 16-23 bits )
@rshift32-3 ( x** n^ -> x>>n )
    #18 SUB STH                 ( stash [n>>24] )
    POP2 POP STH SWPr SFTr #00 #0000 STHr JMP2r

( shift left by 0-7 bits )
@lshift32-0 ( x** n^ -> x<<n )
    #40 SFT !shift32-0

( shift left by 8-15 bits )
@lshift32-1 ( x** n^ -> x<<n )
    #08 SUB #40 SFT STH ( stash [n-8]<<4 )
        DUP2 STHkr SFT2 ,&z1 STR2
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    NIP LIT2 [ &z1 $2 ] #00 JMP2r

( shift left by 16-23 bits )
@lshift32-2 ( x** n^ -> x<<n )
    #10 SUB #40 SFT STH ( stash [n-16]<<4 )
    NIP2 STHr SFT2 #0000 JMP2r

( shift left by 24-31 bits )
@lshift32-3 ( x** n^ -> x<<n )
    #18 SUB #40 SFT ( stash [n-24]<<4 )
    SFT NIP2 NIP #0000 #00 JMP2r

( x < y )
@lt32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 JMP2r } GTH2 #00 EQU JMP2r

( x > y )
@gteq32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 #00 EQU JMP2r } GTH2 JMP2r

( x / y )
@div32 ( x** y** -> q** )
    z_divmod32 ;z_divmod32/quo0 LDA2 ;z_divmod32/quo1 LDA2 JMP2r

( private: calculate and store x / y and x % y )
@z_divmod32 ( x** y** -> )
    ( ; store y and x for repeated use )
    #0000 DUP2 ,&quo0 STR2 ,&quo1 STR2      ( x** y**         ; quo<-0 )
    STH2k ,&div1 STR2 STH2k ,&div0 STR2     ( x** [ylo* yhi*] ; div<-y )
    OVR2 OVR2 ,&rem1 STR2 ,&rem0 STR2       ( x** [ylo* yhi*] ; rem<-x )
    OVR2 OVR2 STH2r STH2r                   ( x** x** y** )
    OVR2 OVR2 STH2 STH2                     ( x** x** y** [ylo* yhi*] )
    gteq32 ?{ POP2 POP2 POP2r POP2r JMP2r } ( x** [ylo* yhi*] ; return if x < y )

    ( ; bitcount[x] - bitcount[y] determines largest multiple of y to try )
    bitcount32 STH2r STH2r bitcount32 SUB ( shift=rbits-dits^ )
    #00 DUP2                              ( shift^ 0^ shift^ 0^ )
    #0000 INC2k ROT2 POP                  ( shift^ 0^ 0* 1* shift^ )
    lshift32 ,&cur1 STR2 ,&cur0 STR2      ( shift^ 0^ ; cur<-1<<shift )
    ,&div0 LDR2 ,&div1 LDR2 ROT2 POP      ( div** shift^ )
    lshift32 ,&div1 STR2 ,&div0 STR2      ( ; div<-div<<shift )

    &loop
      ( ; if rem >= cur [current divisor], we can subtract it and add to quotient )
      ( ; otherwise, skip that iteration and reduce cur. )
      LIT2 [ &rem0 $2 ] LIT2 [ &rem1 $2 ] ,&div0 LDR2 ,&div1 LDR2
      lt32 ?{
        ( ; since rem >= div, we have found a multiple of y that divides x )
        ,&rem0 LDR2 ,&rem1 LDR2             ( rem** )
        LIT2 [ &div0 $2 ] LIT2 [ &div1 $2 ] ( rem** div** )
        sub32 ,&rem1 STR2 ,&rem0 STR2       ( ; rem<-rem-div** )
        LIT2 [ &quo0 $2 ] LIT2 [ &quo1 $2 ] ( quo** )
        LIT2 [ &cur0 $2 ] LIT2 [ &cur1 $2 ] ( quo** cur** )
        add32 ,&quo1 STR2 ,&quo0 STR2       ( ; quo<-quo+cur** )
      }
      ,&div0 LDR2 ,&div1 LDR2 #01 rshift32 ( div>>1** )
      ,&div1 STR2 ,&div0 STR2              ( ; div<-div>>1 )
      ,&cur0 LDR2 ,&cur1 LDR2 #01 rshift32 ( cur>>1** )
      OVR2 OVR2 ,&cur1 STR2 ,&cur0 STR2    ( cur>>1** ; cur<-cur>>1 )
      non-zero32 ?&loop JMP2r              ( ; loop if cur>0, else we're done )


@part [ 
	( partition boundaries: start inclusive, end inclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00   
	&b-beg 00 &b-end 00   
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0100 &g-sort $0100 &b-sort $0100
]

@part1 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0100 &g-sort $0100 &b-sort $0100
]

@part2 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0100 &g-sort $0100 &b-sort $0100
]

@part3 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $0100 &g-sort $0100 &b-sort $0100
]

@filename "image.ff $0800
@file-buf-pre $20
@file-buf [ $3fe0 &pre-end $20 &end ]


( signed 8-bit values of quantization errors. divided by 2 )
( 0x1000 = 4096 pixels per line max )
( a couple bytes of padding, so that dithering algorithm does not need
  to check bounds )
@dither-buffer [ 
	$1 &r $1000 $1
	$1 &g $1000 $1
	$1 &b $1000 $1
]
@end
