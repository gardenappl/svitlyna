|00 @System [ 
	&vector $2 &expansion $2 &wst $1 &rst $1 
	&metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1 
]
|10 @Console [ 
	&vector $2 &read $1 &pad $4 
	&type $1 &write $1 &error $1
]
|20 @Screen [ 
	&vector $2 &width $2 &height $2 &auto $1 &pad 
	$1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1600
]
|a0 @File [ 
	&vector $2 &success $2 &stat $2 &delete $1 
	&append $1 &name $2 &length $2 &read $2 &write $2
]

|0000 
@x $2 @y $2
@img-w $2 @img-h $2

( see bottom of file for reasoning )
%Mmax-w-smol { #0200 }
%Mmax-w-big { #1000 }

%Mmax-name-length { #00ff }

@color0 [ &r $1 &g $1 &b $1 ]
@color1 [ &r $1 &g $1 &b $1 ]
@color2 [ &r $1 &g $1 &b $1 ]
@color3 [ &r $1 &g $1 &b $1 ]

(       Farbfeld                 )
(	ff-magic-2 ff-pixel      )
@buf [
	&ff-w-high &ff-r     $2
	&ff-w-low  &ff-g     $2     
	&ff-h-high &ff-b     $2
	&ff-h-low  &ff-a     $10
]
@buf-size-expect $1 @buf-on-read $2
%Mbuf-next { .buf-on-read STZ2 .buf-size-expect STZ }

%Mprint-short { SWP print-byte print-byte }
%Mcout { .Console/write DEO }
%Mendl { #0a .Console/write DEO }
%Mprint-bgr { 
	LIT "# Mcout 
	print-byte print-byte print-byte Mendl 
}
%Mprint-rgb { 
	LIT "# Mcout 
	STH OVR print-byte 
	DUP print-byte
	STHr DUP print-byte Mendl
}
%Mdump-buffer {
	#00
	&dump-buffer-loop 
		DUP print-byte #20 Mcout
		DUP .buf ADD LDZ DUP print-byte 
		LIT "| Mcout Mcout Mendl
		INC DUP #08 NEQ 
	?&dump-buffer-loop
	POP
}


|0100
( init )
	;str/init print-str
	( hardcoded colors for now )
	#0f0f .color0 STZ2 #0f .color0/b STZ
	#0f00 .color1 STZ2 #00 .color1/b STZ
	#000f .color2 STZ2 #00 .color2/b STZ
	#0000 .color3 STZ2 #0f .color3/b STZ
	( #0f0f .color0 STZ2 #0f .color0/b STZ )
	( #0a0a .color1 STZ2 #0a .color1/b STZ )
	( #0505 .color2 STZ2 #05 .color2/b STZ )
	( #0000 .color3 STZ2 #00 .color3/b STZ )
	prepare-palette


	#01 .Screen/auto DEO

	#08 ;detect-magic Mbuf-next

	.Console/type DEI ?{ 
		;str/start print-str ;str/start-stdin print-str
		;on-stdin .Console/vector DEO2 
	BRK 
	}

	;read-argument .Console/vector DEO2
BRK




( i/o )


@on-stdin ( -> )
	LIT [ &index 00 ] 
	( DUP print-byte LIT "& Mcout .Console/read DEI print-byte Mendl )
	DUP .buf ADD .Console/read DEI SWP STZ
	INC DUP .buf-size-expect LDZ NEQ ?{
		( Mdump-buffer )
		( call subroutine )
		.buf-on-read LDZ2 JSR2
		.buf-on-read LDZ2 ;after-end NEQ2 ?{ 
			#0000 .Console/vector DEO2
			( #0000 .Screen/vector DEO2 )
		}
		POP #00
	}
	[ ,&index STR ]
BRK


@read-argument ( -> )
	.Console/type DEI 
	DUP #03 NEQ ?{
		;str/usage !fail-str
	}
	#02 EQU ?{ 
		#0000 .Console/vector DEO2
		;on-read-argument .Screen/vector DEO2
		BRK
	}
	.Console/read DEI 
	[ ,&name-length LDR2 ] ;filename ADD2 STA
	[ ,&name-length LDR2 ] INC2 
	DUP2 Mmax-name-length LTH2 ?{
		;str/filename-big !fail-str
	}

	[ ,&name-length STR2 ]
BRK 
	&name-length 0000


@on-read-argument ( -> )
	#0000 .Screen/vector DEO2
	;str/start print-str
	;str/start-file print-str
	;filename print-str
	Mendl
	

	;filename .File/name DEO2

	( print loop )
	&loop
		#00 .buf-size-expect LDZ .File/length DEO2
		( ;buf Mprint-short #00 .buf Mprint-short Mendl )
		;buf .File/read DEO2

		( shouldn't read more than 255 bytes )
		.File/success DEI2 #00 .buf-size-expect LDZ 
		EQU2 ?{ !bad-file }


		( call subroutine )
		.buf-on-read LDZ2 JSR2

		.buf-on-read LDZ2 ;after-end NEQ2
	?&loop
BRK




( image format )


@detect-magic ( -- )
	LIT "m Mcout Mendl
	#0000
	&loop
		DUP2
		;&magic ADD2 LDA #00 EQU ?&loop-end
		DUP2 ;&magic ADD2 LDA 
		OVR .buf ADD LDZ
		DUP .Console/write DEO 
		EQU ?{ !bad-file }
		INC2 
	!&loop
	[ &magic "farbfeld 00 ]
	&loop-end

	Mendl 
	#08 ;ff-size Mbuf-next
	POP2 
JMP2r


@ff-size ( -- )
	.buf/ff-w-high LDZ2 #0000 EQU2 ?{ !too-large }
	.buf/ff-w-low LDZ2 
	DUP2 Mprint-short Mendl
	.buf/ff-h-high LDZ2 #0000 EQU2 ?{ !too-large }
	.buf/ff-h-low LDZ2
	DUP2 Mprint-short Mendl
	OVR2 Mprint-short Mendl

	handle-image-size

	#08 ;ff-max-channel-variation Mbuf-next
JMP2r

	
( farbfeld uses 16-bit depth, not alpha-premultiplied ) 
( we discard the lower 10 bits )
( use 4 bits directly, if alpha is not present )
( or, multiply 2 bit color with 2 bit alpha to get 4 bits )
@ff-get-next-color ( -- r g b )
	( 255 INC becomes 0, so lambda isn't skipped -> opaque )
	.buf/ff-a LDZ DUP INC ?{
		POP
		( LIT "# Mcout )
		.buf/ff-r LDZ #04 SFT
		( DUP print-byte )
		.buf/ff-g LDZ #04 SFT
		( DUP print-byte )
		.buf/ff-b LDZ #04 SFT
		( DUP print-byte )
		( LIT "< Mcout )
		( .buf/ff-b LDZ .buf/ff-g LDZ .buf/ff-r LDZ Mprint-bgr )
	JMP2r 
	}
	#06 SFT 
	DUP .buf/ff-r LDZ #06 SFT MUL
	DUP .buf/ff-g LDZ #06 SFT MUL
	DUP .buf/ff-b LDZ #06 SFT MUL
JMP2r




( misc. )


@handle-image-size ( w* h* -- )
	;str/height print-str DUP2 Mprint-short Mendl

	DUP2k .Screen/height DEO2 .img-h STZ2
	.Screen/height DEI2 EQU2 ?{
		( ;str/height print-str .Screen/height DEI2  )
		( Mprint-short Mendl )
		( #01 .no-fullscreen STZ )
	}

	;str/width print-str DUP2 Mprint-short Mendl

	DUP2 Mmax-w-big LTH2 ?{ !too-large }
	DUP2k .Screen/width DEO2 .img-w STZ2
	.Screen/width DEI2 EQU2 ?{
		( ;str/width print-str .Screen/width DEI2  )
		( Mprint-short Mendl )
		( #01 .no-fullscreen STZ )
	}
	( .no-fullscreen LDZ #00 EQU ?{ ;str/cannot-fullscreen !fail-str } )

	( Mmax-w-smol LTH2 ?{ 
		( memory check )
		LIT "! #ffff STA
		#ffff LDA LIT "! EQU ?{
			#01 .no-dithering STZ 
		}
		LIT "? #ffff STA
		#ffff LDA LIT "? EQU ?{
			#01 .no-dithering STZ 
		}
	}

	Mmax-w-big LTH2 ?{ 
		#01 .no-dithering STZ 
	}
	.no-fullscreen LDZ SUB ?{ ;str/cannot-fullscreen !fail-str } )
JMP2r




( image processing )


@ff-max-channel-variation ( -- )
	ff-get-next-color
	[ ,&bmax LDR ] LTHk ?{ SWP DUP [ ,&bmax STR ] SWP } POP
	[ ,&bmin LDR ] GTHk ?{ SWP DUP [ ,&bmin STR ] SWP } POP2
	[ ,&gmax LDR ] LTHk ?{ SWP DUP [ ,&gmax STR ] SWP } POP
	[ ,&gmin LDR ] GTHk ?{ SWP DUP [ ,&gmin STR ] SWP } POP2
	[ ,&rmax LDR ] LTHk ?{ SWP DUP [ ,&rmax STR ] SWP } POP
	[ ,&rmin LDR ] GTHk ?{ SWP DUP [ ,&rmin STR ] SWP } POP2
	advance-pos ?{
		!{ 
			&rmin ff &rmax 00 
			&gmin ff &gmax 00 
			&bmin ff &bmax 00 
		}
		LIT "R Mcout [ ;&rmax LDA ] print-byte
		LIT "r Mcout [ ;&rmin LDA ] print-byte
		LIT "G Mcout [ ;&gmax LDA ] print-byte
		LIT "g Mcout [ ;&gmin LDA ] print-byte
		LIT "B Mcout [ ;&bmax LDA ] print-byte
		LIT "b Mcout [ ;&bmin LDA ] print-byte
		#80 .System/state DEO BRK
	}
	Mendl
JMP2r


( @ff-avg-color-init ( -- ) )
( 	ff-get-next-color )
( 	[ ,avgcolor/b STR ] [ ,avgcolor/g STR ] [ ,avgcolor/r STR ] )
( 	#08 ;ff-avg-color Mbuf-next )
( 	#01 [ ,cumulative-avg/n STR ] )
( JMP2r )

( @cumulative-avg [ &r 00 &g 00 &b 00 &n 00 ] )

( @ff-avg-color ( -- ) )
( 	ff-get-next-color )
( 	[ ,cumulative-avg/b LDR ] SUBk [ ,cumulative-avg/n ] DIV  )
( 	ADD NIP )
( 	[ ,cumulative-avg/g LDR ] SUBk [ ,cumulative-avg/n ] DIV  )
( 	ADD NIP )
( 	[ ,cumulative-avg/r LDR ] SUBk [ ,cumulative-avg/n ] DIV  )
( 	ADD NIP )
( JMP2r )



( printing )


@ff-print ( -- )
	ff-get-next-color
	;color/b STA ;color/g STA ;color/r STA
	pick-color .Screen/pixel DEO
	advance-pos-screen ?{
		;str/end print-str 
		;after-end .buf-on-read STZ2
	}
JMP2r


( probably overkill )
@prepare-palette
	LIT "0 Mcout
	;color0/b LDA ;color0/g LDA ;color0/r LDA Mprint-bgr
	LIT "1 Mcout
	;color1/b LDA ;color1/g LDA ;color1/r LDA Mprint-bgr
	LIT "2 Mcout
	;color2/b LDA ;color2/g LDA ;color2/r LDA Mprint-bgr
	LIT "3 Mcout
	;color3/b LDA ;color3/g LDA ;color3/r LDA Mprint-bgr
	;color0/r LDA DUP ;color0r STA #40 SFT 
	;color1/r LDA DUP ;color1r STA ORA [ ,&rhigh STR ]
	;color2/r LDA DUP ;color2r STA #40 SFT
	;color3/r LDA DUP ;color3r STA ORA [ ,&rlow STR ]
	;color0/g LDA DUP ;color0g STA #40 SFT 
	;color1/g LDA DUP ;color1g STA ORA [ ,&ghigh STR ]
	;color2/g LDA DUP ;color2g STA #40 SFT
	;color3/g LDA DUP ;color3g STA ORA [ ,&glow STR ]
	!{
		&r &rhigh 00 &rlow 00
		&g &ghigh 00 &glow 00
		&b &bhigh 00 &blow 00
	}
	;color0/b LDA DUP ;color0b STA #40 SFT 
	;color1/b LDA DUP ;color1b STA ORA [ ,&bhigh STR ]
	;color2/b LDA DUP ;color2b STA #40 SFT
	;color3/b LDA DUP ;color3b STA ORA [ ,&blow STR ]

	LIT "R Mcout [ ,&r LDR2 ] Mprint-short
	LIT "G Mcout [ ,&g LDR2 ] Mprint-short
	LIT "B Mcout [ ,&b LDR2 ] Mprint-short
	Mendl

	[ ,&r LDR2 ] .System/r DEO2
	[ ,&g LDR2 ] .System/g DEO2
	[ ,&b LDR2 ] .System/b DEO2
JMP2r


( chooses closest color from palette )
@pick-color ( -- c )
	( LIT "0 Mcout )
	( ;color0/r LDA ;color0/g LDA ;color0/b LDA Mprint-bgr )
	( LIT "1 Mcout )
	( ;color1/r LDA ;color1/g LDA ;color1/b LDA Mprint-bgr )
	( LIT "2 Mcout )
	( ;color2/r LDA ;color2/g LDA ;color2/b LDA Mprint-bgr )
	( LIT "3 Mcout )
	( ;color3/r LDA ;color3/g LDA ;color3/b LDA Mprint-bgr )
	( LIT "o Mcout )
	( ,color/b LDR ,color/g LDR ,color/r LDR Mprint-bgr )
	#00
	( wst: min-dist-color min-dist cur-dist.. )
	[ ,color/r LDR ] [ LIT @color0r $1 ] GTHk ?{ SWP } SUB
	[ ,color/g LDR ] [ LIT @color0g $1 ] GTHk ?{ SWP } SUB ADD
	[ ,color/b LDR ] [ LIT @color0b $1 ] GTHk ?{ SWP } SUB ADD
	
	[ ,color/r LDR ] [ LIT @color1r $1 ] GTHk ?{ SWP } SUB
	[ ,color/g LDR ] [ LIT @color1g $1 ] GTHk ?{ SWP } SUB ADD
	[ ,color/b LDR ] [ LIT @color1b $1 ] GTHk ?{ SWP } SUB ADD
	LTHk ?{ NIP NIP #01 SWP !color-2-check } POP
	
	!{ @color [ &r 00 &g 00 &b 00 ] }

	@color-2-check
	[ ,color/r LDR ] [ LIT @color2r $1 ] GTHk ?{ SWP } SUB
	[ ,color/g LDR ] [ LIT @color2g $1 ] GTHk ?{ SWP } SUB ADD
	[ ,color/b LDR ] [ LIT @color2b $1 ] GTHk ?{ SWP } SUB ADD
	LTHk ?{ NIP NIP #02 SWP !color-3-check } POP
	
	@color-3-check
	[ ,color/r LDR ] [ LIT @color3r $1 ] GTHk ?{ SWP } SUB
	[ ,color/g LDR ] [ LIT @color3g $1 ] GTHk ?{ SWP } SUB ADD
	[ ,color/b LDR ] [ LIT @color3b $1 ] GTHk ?{ SWP } SUB ADD
	LTH ?{ POP #03 }

	( LIT "= Mcout DUP print-byte Mendl )
JMP2r


@advance-pos ( -- continue )
	( LIT "x Mcout .x LDZ2 Mprint-short )
	( LIT "y Mcout .y LDZ2 Mprint-short Mendl )
	.x LDZ2 INC2 .img-w LDZ2 NEQ2k ?{
		POP2 POP2 #0000 .x STZ2
		.y LDZ2 INC2
		DUP2 .y STZ2
		.img-h LDZ2 NEQ2
	JMP2r }
	POP2 .x STZ2
	#01
JMP2r


( assumes screen auto )
@advance-pos-screen ( -- continue )
	.Screen/x DEI2 .img-w LDZ2 NEQ2 ?{
		#0000 .Screen/x DEO2 
		.Screen/y DEI2 INC2 
		DUP2 .Screen/y DEO2 
		.img-h LDZ2 NEQ2
	JMP2r }
	#01
JMP2r




( end )


@after-end ( -- )
	;str/after-end print-str	
JMP2r




( utils and stdlib )


@print-str ( str* -- )
	&while ( -- )
		LDAk .Console/write DEO
		INC2 LDAk 
	?&while
	POP2 
JMP2r

@print-byte ( b -- )
	DUP #04 SFT DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO

	#0f AND DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO
JMP2r
	

@bad-file 
	;&str 
!fail-str
	&str "...Bad 20 "file 00


@too-large
	;&str 
!fail-str
	&str "...Too 20 "large 00


@fail-str ( error-msg* -> )
	print-str
( -> )
@fail ( -> )
	#01 .System/state DEO
BRK


@str [
	&init "Hello! 0a 00
	&start "Reading 20 00
	&start-file "file: 20 00
	&start-stdin "standard 20 "input... 0a 00
	&end "Готово! 0a 00
	&usage "Usage: 20 "svitlyna.rom 20 "image.ff 0a 00
	&cannot-fullscreen "Unable 20 "to 20 "resize 20 "screen. 0a 00
	&width "w: 20 00
	&height "h: 20 00
	&after-end "Warning: 20 
	           "input 20 "after 20 "image 20 "end. 0a 00
	&filename-big "File 20 "name 20 "too 20 "big. 0a 00
	&divided-colors "Divided 20 "colors. 0a 00
]



( 9 lines are needed: at least 8 to export a sprite,
  multiple of 3 to use dithering )
( smol 
	lines:   #1000-#1d80
	         0x0180 = 384 bytes per line
	         384 / 3 * 4 = 512 pixels per line
	sprites: #1d80-#1ddd
	         0x0080 = 128 bytes total
		 128 * 4 = 512 pixels per line )
|1000 @lines-smol    !fail ( upper limit for smol code )
|1d80 @sprite-smol


|1e00 @filename


|1f00 @quantization-buckets


( big, is 8x smol
	lines:   #8000-#ec00
	         0x0c00 = 3072 bytes per line
	         3072 / 3 * 4 = 4096 pixels per line
	sprites: #ec00-#f000
	         0x0400 = 1024 bytes total
		 1024 * 4 = 4096 pixels per line )
|8000 @lines-big
|ec00 @sprite-big
