|00 @System [ 
	&vector $2 &expansion $2 &wst $1 &rst $1 
	&metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1 
]
|10 @Console [ 
	&vector $2 &read $1 &pad $4 
	&type $1 &write $1 &error $1
]
|20 @Screen [ 
	&vector $2 &width $2 &height $2 &auto $1 &pad 
	$1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1600
]
|a0 @File [ 
	&vector $2 &success $2 &stat $2 &delete $1 
	&append $1 &name $2 &length $2 &read $2 &write $2
]

|0000 

@x $2 @y $2 @xfrac $2 @yfrac $2
@decode-x $2 @decode-y $2 @line-buf $1
@img-w $2 @img-h $2 @img-size $4

%Mmax-width { #1000 }
%Mmax-height { #1000 }
%Mmax-name-length { #07ff }

@color0 [ &r $1 &g $1 &b $1 ]
@color1 [ &r $1 &g $1 &b $1 ]
@color2 [ &r $1 &g $1 &b $1 ]
@color3 [ &r $1 &g $1 &b $1 ]

%Mfile-buffer-length { #4000 }
@bytes-expected $2

@on-bytes-received $2
@on-pixel-received $2
@on-file-end $2

@part-split-step $1

%Mcout { .Console/write DEO }
%Mendl { #0a Mcout }

%Mprint-short { SWP print-byte print-byte }
%Mdebug-byte { Mcout DUP print-byte }
%Mdebug-short { Mcout OVR print-byte DUP print-byte }
%Mdebug32 { Mcout OVR2 Mprint-short DUP2 Mprint-short }
%Mdebug-rgb { 
	Mcout LIT "# Mcout 
	ROT DUP print-byte 
	ROT DUP print-byte
	ROT DUP print-byte
}

%Mprint-bgr { 
	LIT "# Mcout 
	print-byte print-byte print-byte Mendl 
}
%Mprint-rgb { 
	LIT "# Mcout 
	STH OVR print-byte 
	DUP print-byte
	STHr DUP print-byte Mendl
}

%Msk+ { STH2kr ADD2 }
%Ms+ { STH2r ADD2 }


|0100
( init )
	( memory check )
	#1234 ;end STA2
	;end LDA2 #1234 EQU2 ?{ ;str/memory-error !fail }

	[ #0000 #00 ] .color0/b STZ .color0/g STZ .color0/r STZ
	[ #0505 #05 ] .color1/b STZ .color1/g STZ .color1/r STZ
	[ #0909 #09 ] .color2/b STZ .color2/g STZ .color2/r STZ
	[ #0f0f #0f ] .color3/b STZ .color3/g STZ .color3/r STZ
	( [ #0000 #04 ] .color0/b STZ .color0/g STZ .color0/r STZ )
	( [ #0800 #00 ] .color1/b STZ .color1/g STZ .color1/r STZ )
	( [ #000a #00 ] .color2/b STZ .color2/g STZ .color2/r STZ )
	( [ #0f0f #0f ] .color3/b STZ .color3/g STZ .color3/r STZ )
	prepare-palette
	;str/init print-str

	#01 .Screen/auto DEO

	.Console/type DEI ?{ 
		;on-stdin .Console/vector DEO2	
		;str/read print-str ;str/read-stdin print-str

		;detect-magic .on-bytes-received STZ2
		#0008 .bytes-expected STZ2
		;display .on-pixel-received STZ2
		BRK 
	}

	;read-argument .Console/vector DEO2
BRK


@on-stdin ( -> )
	( LIT ". Mcout )
	[ LIT2 &index 0000 ] 
	DUP2 ;file-buf ADD2 
	.Console/read DEI ROT ROT STA
	INC2 DUP2 .bytes-expected LDZ2 NEQ2 ?{
		( LIT "! Mcout )
		( call subroutine )
		;file-buf .on-bytes-received LDZ2 JSR2
		POP2 #0000 [ ,&index STR2 ]
		BRK
	}
	[ ,&index STR2 ]
BRK


@read-argument ( -> )
	.Console/type DEI 
	DUP #03 NEQ ?{
		;str/usage !fail-str
	}
	#02 EQU ?{ 
		#00 [ ,&name-length LDR2 ] ;filename ADD2 STA
		Mendl
		
		#00 .part-split-step STZ
		( !palette-split-init )
		!display-init
	}
	.Console/read DEI 
	[ ,&name-length LDR2 ] ;filename ADD2 STA
	[ ,&name-length LDR2 ] INC2 
	DUP2 Mmax-name-length LTH2 ?{
		;str/filename-big !fail-str
	}

	[ ,&name-length STR2 ]
BRK 
	&name-length 0000


@read-file ( -> )
	;str/read print-str ;str/read-file print-str
	;filename print-str Mendl

	#0008 .bytes-expected STZ2
	;detect-magic .on-bytes-received STZ2
	( #0005 .bytes-expected STZ2 )
	( ;echo-file .on-bytes-received STZ2 )

	;filename .File/name DEO2
	Mfile-buffer-length .File/length DEO2

	;file-buf ;read-buffer/window STA2
	;read-buffer .Screen/vector DEO2
BRK


@read-buffer ( -> )
	;file-buf 
	DUP2 .File/read DEO2
	.File/success DEI2 ADD2 [ ,&window-end STR2 ]

	&loop
		[ LIT2 &window =file-buf ] 
		DUP2 .bytes-expected LDZ2 ADD2 ( next window )
		[ LIT2 &window-end =file-buf/end ]
		GTH2k ?{
			POP2
			[ ,&window STR2 ]
			.on-bytes-received LDZ2 JSR2
			!&loop

			( copy cmd )
			&cmd [ 
				01 0020 0000 =file-buf/pre-end 
				0000 =file-buf-pre 
			]
		}
		( not enough bytes )
		( LIT ". Mcout )

		;file-buf/end NEQ2 ?{
			( buffer full )
			( copy last 20 bytes to pre-buffer )
			;&cmd .System/expansion DEO2
			POP2
			Mfile-buffer-length SUB2 [ ,&window STR2 ]

			( a good time to take a break? )
			[ LIT &break-counter 00 ] INC
			DUP #40 NEQ ?{
				POP #00 [ ,&break-counter STR ]
				BRK	
			}
			[ ,&break-counter STR ]
			!read-buffer
		}
		#0000 .Screen/vector DEO2
		.on-file-end LDZ2 JMP2
BRK




( image formats )


@detect-magic ( {buffer}* -- )
	STH2
	#00
	&loop
		#00 OVR Msk+ LDA
		DUP .Console/write DEO 
		OVR #00 SWP ;&magic ADD2 LDA 
		DUP ?{ !&loop-end }
		EQU ?{ !bad-file }
		INC
	!&loop
	[ &magic "farbfeld 00 ]
	&loop-end

	POP POP2r
	Mendl 

	;ff-size .on-bytes-received STZ2
	#0008 .bytes-expected STZ2
JMP2r


@ff-size ( {buffer}* -- )
	DUP2 LDA2 #0000 EQU2 ?{ !too-large } INC2 INC2
	DUP2 LDA2 ( width ) SWP2 INC2 INC2
	DUP2 LDA2 #0000 EQU2 ?{ !too-large } INC2 INC2
	     LDA2 ( height )

	handle-image-size

	#0008 .bytes-expected STZ2
	;ff-next-pixel .on-bytes-received STZ2
JMP2r

	
( farbfeld uses 16-bit depth, not alpha-premultiplied ) 
( we don't load the lower 8 bits )
@ff-next-pixel ( {buffer}* -- )
	STH2k #0006 ADD2 LDA ( alpha )
	( 255 INC becomes 0, so lambda isn't skipped -> opaque )
	DUP INC ?{
		( alpha is zero )
		POP
		STH2kr     LDA #04 SFT ( r )
		#0002 Msk+ LDA #04 SFT ( g )
		#0004 Ms+  LDA #04 SFT ( b )
		.on-pixel-received LDZ2 JSR2
		JMP2r
	}
	#00 SWP
	DUP2 #00 STH2kr     LDA MUL2 POP #04 SFT ( 00 aa a*r )
	ROT ROT
	DUP2 #00 #0002 Msk+ LDA MUL2 POP #04 SFT ( 00 aa a*g )
	ROT ROT
	     #00 #0004 Ms+  LDA MUL2 POP #04 SFT ( ar ag a*b )
	.on-pixel-received LDZ2 JSR2
JMP2r




( misc. )


@handle-image-size ( w* h* -- )
	;str/height print-str DUP2 Mprint-short Mendl

	DUP2 .Screen/height DEO2 .img-h STZ2

	;str/width print-str DUP2 Mprint-short Mendl

	DUP2 .Screen/width DEO2 .img-w STZ2
JMP2r


@prepare-palette ( -- )
	LIT "0 Mcout
	;color0/b LDA ;color0/g LDA ;color0/r LDA Mprint-bgr
	LIT "1 Mcout
	;color1/b LDA ;color1/g LDA ;color1/r LDA Mprint-bgr
	LIT "2 Mcout
	;color2/b LDA ;color2/g LDA ;color2/r LDA Mprint-bgr
	LIT "3 Mcout
	;color3/b LDA ;color3/g LDA ;color3/r LDA Mprint-bgr

	;color0/r LDA DUP ;pick-color/color0r STA #40 SFT 
	;color1/r LDA DUP ;pick-color/color1r STA ORA [ ,&rhigh STR ]
	;color2/r LDA DUP ;pick-color/color2r STA #40 SFT
	;color3/r LDA DUP ;pick-color/color3r STA ORA [ ,&rlow STR ]
	;color0/g LDA DUP ;pick-color/color0g STA #40 SFT 
	;color1/g LDA DUP ;pick-color/color1g STA ORA [ ,&ghigh STR ]
	;color2/g LDA DUP ;pick-color/color2g STA #40 SFT
	;color3/g LDA DUP ;pick-color/color3g STA ORA [ ,&glow STR ]
	!{
		&r &rhigh 00 &rlow 00
		&g &ghigh 00 &glow 00
		&b &bhigh 00 &blow 00
	}
	;color0/b LDA DUP ;pick-color/color0b STA #40 SFT 
	;color1/b LDA DUP ;pick-color/color1b STA ORA [ ,&bhigh STR ]
	;color2/b LDA DUP ;pick-color/color2b STA #40 SFT
	;color3/b LDA DUP ;pick-color/color3b STA ORA [ ,&blow STR ]

	LIT "R Mcout [ ,&r LDR2 ] Mprint-short
	LIT "G Mcout [ ,&g LDR2 ] Mprint-short
	LIT "B Mcout [ ,&b LDR2 ] Mprint-short
	Mendl

	[ ,&r LDR2 ] .System/r DEO2
	[ ,&g LDR2 ] .System/g DEO2
	[ ,&b LDR2 ] .System/b DEO2
JMP2r




( image processing )


( partitioning color space, via median cut algorithm )

( see bottom of file for file structure )
%Mpart-size { #00ca } 


@part-debug ( part -- )
	#00 OVR Mpart-size MUL2 STH2
	( { "part 20 00 } STH2r print-str DUP print-byte Mcout )
	LIT "R Mcout ;part/r-beg Msk+ LDA2 
	SWP print-byte LIT "- Mcout print-byte LIT ", Mcout
	LIT "G Mcout ;part/g-beg Msk+ LDA2
	SWP print-byte LIT "- Mcout print-byte LIT ", Mcout
	LIT "B Mcout ;part/b-beg Msk+ LDA2
	SWP print-byte LIT "- Mcout print-byte Mendl

	.part-split-step LDZ INC LTH ?{ POP2r JMP2r }

	LIT "C Mcout ;part/count Msk+ 
	LDA2k Mprint-short INC2 INC2 LDA2 Mprint-short Mendl

	#0000 
	LIT "S Mcout LIT "R Mcout Mendl
	&loopr
		DUP #02 SFT 
		print-byte LIT "| Mcout
		DUP2 ;part/r-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/r-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		#20 Mcout
		DUP2 
		DUP #40 SFT #00 NEQ ?{ Mendl }
		#0040 NEQ2
	?&loopr

	POP2 #0000 
	LIT "S Mcout LIT "G Mcout Mendl
	&loopg
		DUP #02 SFT 
		print-byte LIT "| Mcout
		DUP2 ;part/g-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/g-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		#20 Mcout
		DUP2 
		DUP #40 SFT #00 NEQ ?{ Mendl }
		#0040 NEQ2
	?&loopg

	#0000 
	LIT "S Mcout LIT "B Mcout Mendl
	&loopb
		DUP #02 SFT 
		print-byte LIT "| Mcout
		DUP2 ;part/b-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		DUP2 ;part/b-sort Msk+ ADD2 LDA2 Mprint-short
		INC2 INC2 
		#20 Mcout
		DUP2 
		DUP #40 SFT #00 NEQ ?{ Mendl }
		#0040 NEQ2
	?&loopb
	POP2
	Mendl POP2r
JMP2r


@part-init ( part -- )
	#00 SWP Mpart-size MUL2 STH2
	#0000 ;part/count Msk+ STA2k
	INC2 INC2 STA2
	#0000 
	&loop
		#0000 OVR2 ;part/r-sort ADD2 Msk+ STA2
		INC2 INC2 DUP2 #00c0 NEQ2
	?&loop
	POP2 POP2r
JMP2r


@part-add-pixel ( r g b part -- )
	#00 SWP Mpart-size MUL2 STH2
	#20 SFT #00 SWP ;part/b-sort Msk+ ADD2 inc32-addr
	#20 SFT #00 SWP ;part/g-sort Msk+ ADD2 inc32-addr
	#20 SFT #00 SWP ;part/r-sort Msk+ ADD2 inc32-addr
	;part/count Ms+ inc32-addr
JMP2r 


( get color variation within partition )
@part-get-max-var ( part -- max-var-chan max-var )
	#00 SWP Mpart-size MUL2 
	STH2
	( load 32-bit count )
	;part/count Msk+ LDA2k SWP2 INC2 INC2 LDA2 
	non-zero32 ?{ POP2r #0000 JMP2r }

	( order of preference:
	  if green has equal variation to red or blue, prefer green
	  if red has equal variation to blue, prefer red )

	( find index of first non-zero element )
	#00
	&find-g-min
		#00 OVR #20 SFT ;part/g-sort ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-g-min
		INC
	!&find-g-min
	&found-g-min
	( find index of last non-zero element + 1 )
	#0f
	&find-g-max
		#00 OVR #20 SFT ;part/g-sort ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-g-max
		#01 SUB
	!&find-g-max
	&found-g-max
	SWP SUB
	LIT "V Mcout LIT "G Mcout DUP print-byte

	( find index of first non-zero element )
	#00
	&find-r-min
		#00 OVR #20 SFT ;part/r-sort ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-r-min
		INC
	!&find-r-min
	&found-r-min
	( find index of last non-zero element + 1 )
	#0f
	&find-r-max
		#00 OVR #20 SFT ;part/r-sort ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-r-max
		#01 SUB
	!&find-r-max
	&found-r-max
	SWP SUB
	LIT "V Mcout LIT "R Mcout DUP print-byte

	( find index of first non-zero element )
	#00
	&find-b-min
		#00 OVR #20 SFT ;part/b-sort ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-b-min
		INC
	!&find-b-min
	&found-b-min
	( find index of last non-zero element + 1 )
	#0f
	&find-b-max
		#00 OVR #20 SFT ;part/b-sort ADD2 Msk+
		LDA2k SWP2 INC2 INC2 LDA2 non-zero32 ?&found-b-max
		#01 SUB
	!&find-b-max
	&found-b-max
	SWP SUB
	LIT "V Mcout LIT "B Mcout DUP print-byte
	Mendl


	POP2r

	#03 STH
	( wst: gvar rvar max-var | rst: max-var-chan )
	LTHk ?{ POPr #01 STH SWP } NIP 
	( wst: gvar max-var | rst: max-var-chan )
	LTHk ?{ POPr #02 STH SWP } NIP 
	
	&done
	STHr SWP
JMP2r


@part-get-median ( {sorted}* {count}* -- median )
	LDA2k SWP2 INC2 INC2 LDA2 #01 shift32-0
	[ ,&halfl STR2 ] [ ,&halfh STR2 ]
	DUP2 #0000 #0000 ROT2

	( sum the sorted pixel values )
	( iterate until sum is half of all values )
	&loop ( buffer* sumh* suml* ptr* )
		LDA2k SWP2 INC2 INC2 LDAk2 SWP2 STH2 add32
		OVR2 OVR2
		[ LIT2 &halfh 0000 LIT2 &halfl 0000 ] lt32 ?{ 
			POP2 POP2 STH2r SWP2 SUB2 #02 SFT2 NIP
			( correction for when median is in first chunk )
			DUP ?{ POP #01 }
			JMP2r	
		}
		STH2r INC2 INC2
	!&loop
!fail


@get-partition-optimize
	#00 ;get-partition/check0 STA

	.part-split-step LDZ
	DUP #01 LTH ?{
		#01 ;get-partition/check0 STA

		;part/r-beg LDA ;get-partition/part0-r-beg STA
		;part/g-beg LDA ;get-partition/part0-g-beg STA
		;part/b-beg LDA ;get-partition/part0-b-beg STA
		;part/r-end LDA ;get-partition/part0-r-end STA
		;part/g-end LDA ;get-partition/part0-g-end STA
		;part/b-end LDA ;get-partition/part0-b-end STA

		#00 ;get-partition/check1 STA
	}
	DUP #02 LTH ?{
		#01 ;get-partition/check1 STA

		;part1/r-beg LDA ;get-partition/part1-r-beg STA
		;part1/g-beg LDA ;get-partition/part1-g-beg STA
		;part1/b-beg LDA ;get-partition/part1-b-beg STA
		;part1/r-end LDA ;get-partition/part1-r-end STA
		;part1/g-end LDA ;get-partition/part1-g-end STA
		;part1/b-end LDA ;get-partition/part1-b-end STA

		#00 ;get-partition/check2 STA
	}
	#03 LTH ?{ 
		#01 ;get-partition/check2 STA

		;part2/r-beg LDA ;get-partition/part2-r-beg STA
		;part2/g-beg LDA ;get-partition/part2-g-beg STA
		;part2/b-beg LDA ;get-partition/part2-b-beg STA
		;part2/r-end LDA ;get-partition/part2-r-end STA
		;part2/g-end LDA ;get-partition/part2-g-end STA
		;part2/b-end LDA ;get-partition/part2-b-end STA
	}
JMP2r


@get-partition ( r g b -- r g b part )
	[ LIT &check0 $1 ] ?{ #00 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part0-r-beg $1 ] LTH ?{ !&r0 } POP2 POP !&part1
	&r0 [ LIT &part0-r-end $1 ] LTH ?{ POP2 !&part1 }

	DUP [ LIT &part0-b-beg $1 ] LTH ?{ !&b0 } POP2 !&part1
	&b0 [ LIT &part0-b-end $1 ] LTH ?{ POP !&part1 }

	DUP [ LIT &part0-g-beg $1 ] LTH ?{ !&g0 } POP !&part1
	&g0 [ LIT &part0-g-end $1 ] LTH ?{ !&part1 }
	#00 JMP2r

	&part1
	[ LIT &check1 $1 ] ?{ #01 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part1-r-beg $1 ] LTH ?{ !&r1 } POP2 POP !&part2
	&r1 [ LIT &part1-r-end $1 ] LTH ?{ POP2 !&part2 }

	DUP [ LIT &part1-b-beg $1 ] LTH ?{ !&b1 } POP2 !&part2
	&b1 [ LIT &part1-b-end $1 ] LTH ?{ POP !&part2 }

	DUP [ LIT &part1-g-beg $1 ] LTH ?{ !&g1 } POP !&part2
	&g1 [ LIT &part1-g-end $1 ] LTH ?{ !&part2 }
	#01 JMP2r

	&part2
	[ LIT &check2 $1 ] ?{ #02 JMP2r }

	ROTk ( r g b g b r )
	DUP [ LIT &part2-r-beg $1 ] LTH ?{ !&r2 } POP2 POP !&part3
	&r2 [ LIT &part2-r-end $1 ] LTH ?{ POP2 !&part3 }

	DUP [ LIT &part2-b-beg $1 ] LTH ?{ !&b2 } POP2 !&part3
	&b2 [ LIT &part2-b-end $1 ] LTH ?{ POP !&part3 }

	DUP [ LIT &part2-g-beg $1 ] LTH ?{ !&g2 } POP !&part3
	&g2 [ LIT &part2-g-end $1 ] LTH ?{ !&part3 }
	#02 JMP2r

	&part3
	( LIT "3 Mdebug-rgb Mendl )
	#03
JMP2r


@palette-split-init ( -> )
	get-partition-optimize

	#00 part-init
	.part-split-step LDZ DUP ?{
		#10 ;part/r-end STA
		#10 ;part/g-end STA
		#10 ;part/b-end STA
	}
	DUP #01 LTH ?{
		#01 part-init 
		#02 LTH ?{
			#02 part-init
		}
	}

	;palette-split .on-pixel-received STZ2
	;palette-split-end .on-file-end STZ2
	;read-file .Screen/vector DEO2
BRK


@palette-split ( r g b -- )
	get-partition
	( LIT "R Mdebug-byte Mendl )
	DUP ?{
		part-add-pixel ( 0 )
		JMP2r
	}
	#01 GTHk ?{
		POP
		part-add-pixel ( 1 )
		JMP2r
	}
	POP
	#02 NEQk ?{
		POP
		part-add-pixel ( 2 )
		JMP2r
	} 
	POP
	part-add-pixel
	JMP2r
JMP2r

@palette-split-end ( -> )
	Mendl Mendl Mendl
	#00 part-debug
	#01 part-debug
	#02 part-debug
	#03 part-debug

	( find partition with largest color variation )

	#00 DUP part-get-max-var
	( max-var-part max-var-chan max-var )
	.part-split-step LDZ ?{ !&found-max-var }
	#01 part-get-max-var 
	ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #01 STH2r !&part2-var
	}
	NIP NIP
	&part2-var
	.part-split-step LDZ #01 GTH ?{ !&found-max-var }
	#02 part-get-max-var ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #02 STH2r !&part3-var
	}
	NIP NIP
	&part3-var
	.part-split-step LDZ #02 GTH ?{ !&found-max-var }
	#03 part-get-max-var ROT LTHk ?{
		( o-var-part o-var-chan max-var-chan max-var o-var )
		POP STH2 POP2 #03 STH2r !&found-max-var
	}
	NIP NIP
	&found-max-var
	.part-split-step LDZ LIT "F Mcout print-byte
	POP

	( split partition )

	DUP #01 NEQ ?{
		POP
		#00 .part-split-step LDZ INC Mpart-size MUL2 
		STH2
		#00 OVR Mpart-size MUL2
		STH2
		( rst: dest-part-offset* src-part-offset* )

		;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r
		;part/r-sort Msk+ ;part/count Msk+ part-get-median DUP 
		;part/r-end Msk+ STA SWP2r ;part/r-beg Msk+ STA SWP2r

		;part/g-beg Msk+ LDA SWP2r ;part/g-beg Msk+ STA SWP2r
		;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r

		;part/b-beg Msk+ LDA SWP2r ;part/b-beg Msk+ STA SWP2r
		;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
		!&split-done
	}
	DUP #02 NEQ ?{
		POP
		#00 .part-split-step LDZ INC Mpart-size MUL2 STH2
		#00 OVR Mpart-size MUL2 STH2
		( rst: dest-part-offset* src-part-offset* )

		;part/r-beg Msk+ LDA SWP2r ;part/r-beg Msk+ STA SWP2r
		;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r

		;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r
		;part/g-sort Msk+ ;part/count Msk+ part-get-median DUP 
		;part/g-end Msk+ STA SWP2r ;part/g-beg Msk+ STA SWP2r

		;part/b-beg Msk+ LDA SWP2r ;part/b-beg Msk+ STA SWP2r
		;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
		!&split-done
	}
	POP
	#00 .part-split-step LDZ INC Mpart-size MUL2 STH2
	#00 OVR Mpart-size MUL2 STH2
	( rst: dest-part-offset* src-part-offset* )

	;part/r-beg Msk+ LDA SWP2r ;part/r-beg Msk+ STA SWP2r
	;part/r-end Msk+ LDA SWP2r ;part/r-end Msk+ STA SWP2r

	;part/g-beg Msk+ LDA SWP2r ;part/g-beg Msk+ STA SWP2r
	;part/g-end Msk+ LDA SWP2r ;part/g-end Msk+ STA SWP2r

	;part/b-end Msk+ LDA SWP2r ;part/b-end Msk+ STA SWP2r
	;part/b-sort Msk+ ;part/count Msk+ part-get-median DUP 
	;part/b-end Msk+ STA SWP2r ;part/b-beg Msk+ STA SWP2r

	&split-done
	POP2r POP2r

	( optimize routines )

	.part-split-step LDZ #01 LTH ?{
		.part-split-step LDZ #02 LTH ?{
			#03 .part-split-step STZ
			!sum-colors-init
		}
		#02 .part-split-step STZ
		!palette-split-init
	}
	#01 .part-split-step STZ
	!palette-split-init
BRK


@sum-colors-init ( -- )
	#00 part-init
	#01 part-init
	#02 part-init
	#03 part-init
	get-partition-optimize

	;palette-split .on-pixel-received STZ2
	;avg-colors .on-file-end STZ2
	;read-file .Screen/vector DEO2
JMP2r



@avg-color ( {chan}* {n}* -- avg-color )
	STH2 STH2
	#0000 #0000 #0000
	( sum** index* | {n}* {chan}* )
	&loop
		DUP2 #0004 MUL2 Msk+ ( count addr for index )
		SWP2 STH2
		LDA2k SWP2 INC2 INC2 LDA2 ( load 32-bit count )
		#0000 STH2kr mul32 ( multiply by index )
		add32
		STH2r INC2
		DUP2 #0010 NEQ2 ?{
			POP2 POP2r
			( sum** | {n}* )
			STH2r
			LDA2k SWP2 INC2 INC2 LDA2
			div32
			( clear high 24 bits and check they're zero )
			SWP2 #0000 EQU2 ?{ !fail }
			SWP #00 EQU ?{ !fail }
			JMP2r
		}
	!&loop
JMP2r


@avg-colors ( -> )
	#00 part-debug
	#01 part-debug
	#02 part-debug
	#03 part-debug

	;part/r-sort ;part/count avg-color .color0/r STZ
	;part/g-sort ;part/count avg-color .color0/g STZ
	;part/b-sort ;part/count avg-color .color0/b STZ

	;part1/r-sort ;part1/count avg-color .color1/r STZ
	;part1/g-sort ;part1/count avg-color .color1/g STZ
	;part1/b-sort ;part1/count avg-color .color1/b STZ

	;part2/r-sort ;part2/count avg-color .color2/r STZ
	;part2/g-sort ;part2/count avg-color .color2/g STZ
	;part2/b-sort ;part2/count avg-color .color2/b STZ

	;part3/r-sort ;part3/count avg-color .color3/r STZ
	;part3/g-sort ;part3/count avg-color .color3/g STZ
	;part3/b-sort ;part3/count avg-color .color3/b STZ

	prepare-palette
	!display-init
BRK



( displaying )


@display-init ( -> )
	;display .on-pixel-received STZ2
	;done .on-file-end STZ2
	;read-file .Screen/vector DEO2
BRK


@display ( r g b -- )
	pick-color .Screen/pixel DEO
	advance-screen-pos
JMP2r


( chooses closest color from palette )
@pick-color ( r g b -- c )
	ROTk ( r g b g b r )
	[ LIT &color0r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color0b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color0g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 #00 JMP2r }
	[ ,&diff0 STR ]

	ROTk ( r g b g b r )
	[ LIT &color1r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color1b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color1g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 #01 JMP2r }
	[ ,&diff1 STR ]

	ROTk ( r g b g b r )
	[ LIT &color2r $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color2b $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color2g $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP2 POP2 #02 JMP2r }
	[ ,&diff2 STR ]

	( r g b )
	[ LIT &color3b $1 ] GTHk ?{ SWP } SUB
	SWP [ LIT &color3g $1 ] GTHk ?{ SWP } SUB ADD
	SWP [ LIT &color3r $1 ] GTHk ?{ SWP } SUB ADD
	DUP ?{ ( diff is 0 ) POP #03 JMP2r }

	#03 SWP
	( wst: cur-min-col cur-min )
	[ LIT &diff0 $1 ] LTHk ?{ NIP #00 SWP ROT } POP
	[ LIT &diff1 $1 ] LTHk ?{ NIP #01 SWP ROT } POP
	[ LIT &diff2 $1 ] LTH ?{ POP #02 }
JMP2r


( assumes screen auto )
@advance-screen-pos ( -- )
	.Screen/x DEI2 .img-w LDZ2 NEQ2 ?{
		#0000 .Screen/x DEO2 
		.Screen/y DEI2 INC2 .Screen/y DEO2 
	}
JMP2r




( end )


@done ( -- )
	( #80 .System/state DEO BRK )
	;str/end print-str
BRK



( errors )
	

@bad-file 
	;&str 
!fail-str
	&str "...Bad 20 "file 00


@too-large
	;&str 
!fail-str
	&str "...Too 20 "large 00


@fail-str ( error-msg* -> )
	print-str
( -> )
@fail ( -> )
	LIT "! Mcout
	#01 .System/state DEO
BRK

@str [
	&init "Hello! 0a 00
	&read "Reading 20 00
	&read-file "file: 20 00
	&read-stdin "standard 20 "input... 0a 00
	&end "Готово! 0a 00
	&usage "Usage: 20 "svitlyna.rom 20 "image.ff 0a 00
	&cannot-fullscreen "Unable 20 "to 20 "resize 20 "screen. 0a 00
	&width "w: 20 00
	&height "h: 20 00
	&after-end "Warning: 20 
	           "input 20 "after 20 "image 20 "end. 0a 00
	&filename-big "File 20 "name 20 "too 20 "big. 0a 00
	&io-error "I/O 20 "error 0a 20 00
	&memory-error "Not 20 "enough 20 "RAM? 0a 20 00
]




( utils and stdlib )


@print-str ( str* -- )
	&while ( -- )
		LDAk .Console/write DEO
		INC2 LDAk 
	?&while
	POP2 
JMP2r

@print-byte ( b -- )
	DUP #04 SFT DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO

	#0f AND DUP #09 GTH #27 MUL 
	ADD [ LIT "0 ] ADD .Console/write DEO
JMP2r

@inc32-addr ( addr* -- )
	DUP2 INC2 INC2 LDA2 INC2 ( inc lower short )
	DUP2 #0000 NEQ2 ?{
		POP2 LDA2k INC2 OVR2 STA2 ( inc upper short )
		#0000 SWP2 INC2 INC2 STA2 
		JMP2r 
	}
	SWP2 INC2 INC2 STA2	
JMP2r




( http://plastic-idolatry.com/erik/nxu/math32.tal )


@bitcount16 ( x* -> n^ )
    LITr 00 &loop ORAk ?{ POP2 STHr JMP2r } #01 SFT2 INCr !&loop

@bitcount32 ( x** -> n^ )
    SWP2 bitcount16 DUP ?{ POP !bitcount16 } #10 NIP2 ADD JMP2r

( x != 0 )
@non-zero32 ( x** -> bool^ )
    ORA2 ORA JMP2r

( x + y )
@add32 ( xhi* xlo* yhi* ylo* -> zhi* zlo* )
    ROT2 STH2k ADD2 STH2k ROT2 ROT2 GTH2r #00 STHr ADD2 ADD2 SWP2 JMP2r

( x - y )
@sub32 ( x** y** -> z** )
    ROT2 STH2k SWP2 SUB2 STH2k ROT2 ROT2 LTH2r #00 STHr ADD2 SUB2 SWP2 JMP2r

( 16-bit multiplication )
@mul16 ( x* y* -> z** )
    ,&y1 STR ,&y0 STR ( save ylo, yhi )
    ,&x1 STR ,&x0 STR ( save xlo, xhi )
    #0000 ,&z1 STR ,&w0 STR ( reset z1 and w0 )

    ( x1 * y1 => z1z2 )
    LIT2 00 [ &x1 $1 ] LIT2 00 [ &y1 $1 ] MUL2 ,&z3 STR ,&z2 STR

    ( x0 * y1 => z0z1 )
    #00 ,&x0 LDR #00 ,&y1 LDR MUL2 ,&z1 LDR2 ADD2 ,&z1 STR2

    ( x1 * y0 => w1w2 )
    #00 ,&x1 LDR #00 ,&y0 LDR MUL2 ,&w2 STR ,&w1 STR

    ( x0 * y0 => w0w1 )
    LIT2 00 [ &x0 $1 ] LIT2 00 [ &y0 $1 ] MUL2 ,&w0 LDR2 ADD2 ,&w0 STR2

    ( add z and a<<8 )
    #00 LIT2 [ &z1 $1 &z2 $1 ] LIT [ &z3 $1 ]
    LIT2 [ &w0 $1 &w1 $1 ] LIT [ &w2 $1 ] #00
    !add32

( ( x * y ) )
@mul32 ( x** y** -> z** )
    ROT2k ( x0* x1* y0* y1* y0* y1* x1* )
    mul16 ,&z1 STR2 ,&z0 STR2 POP2 ( x0* x1* y0* y1* ; sum = [x1*y1] )
    STH2 ROT2 STH2                 ( x1* y0* [y1* x0*] )
    MUL2r MUL2 STH2r ADD2          ( x1*y0+y1*x0* )
    ( [x0*y0]<<32 will completely overflow )
    LIT2 [ &z0 $2 ] ADD2 ( sum += [x0*y1+x1*y0]<<16 )
    LIT2 [ &z1 $2 ] JMP2r

( x >> n )
@rshift32 ( x** n^ -> x>>n )
    DUP #08 LTH ?shift32-0 ( x n )
    DUP #10 LTH ?rshift32-1 ( x n )
    DUP #18 LTH ?rshift32-2 ( x n )
    !rshift32-3 ( x n )

( shift by 0-7 bits; used by both lshift and rshift )
@shift32-0 ( x** n^ -> x>>n )
    STH DUP2 STHkr SFT2                       ,&z2 STR2
    POP DUP2 STHkr SFT2 ,&z2 LDR ORA ,&z2 STR ,&z1 STR
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    LIT [ &z1 $1 ] LIT2 [ &z2 $2 ] JMP2r

( x << n )
@lshift32 ( x** n^ -> x<<n )
    DUP #08 LTH ?lshift32-0 ( x n )
    DUP #10 LTH ?lshift32-1 ( x n )
    DUP #18 LTH ?lshift32-2 ( x n )
    !lshift32-3 ( x n )

( shift right by 8-15 bits )
@rshift32-1 ( x** n^ -> x>>n )
    #08 SUB STH                 ( stash [n>>8] )
    POP DUP2 STHkr SFT2 ,&z2 STR2
    POP      STHr  SFT2 ,&z2 LDR ORA ,&z2 STR
    #00 SWP LIT2 [ &z2 $2 ] JMP2r

( shift right by 16-23 bits )
@rshift32-2 ( x** n^ -> x>>n )
    #10 SUB STH                 ( stash [n>>16] )
    POP2 STHr SFT2 #0000 SWP2 JMP2r

( shift right by 16-23 bits )
@rshift32-3 ( x** n^ -> x>>n )
    #18 SUB STH                 ( stash [n>>24] )
    POP2 POP STH SWPr SFTr #00 #0000 STHr JMP2r

( shift left by 0-7 bits )
@lshift32-0 ( x** n^ -> x<<n )
    #40 SFT !shift32-0

( shift left by 8-15 bits )
@lshift32-1 ( x** n^ -> x<<n )
    #08 SUB #40 SFT STH ( stash [n-8]<<4 )
        DUP2 STHkr SFT2 ,&z1 STR2
    POP      STHr  SFT2 ,&z1 LDR ORA ,&z1 STR
    NIP LIT2 [ &z1 $2 ] #00 JMP2r

( shift left by 16-23 bits )
@lshift32-2 ( x** n^ -> x<<n )
    #10 SUB #40 SFT STH ( stash [n-16]<<4 )
    NIP2 STHr SFT2 #0000 JMP2r

( shift left by 24-31 bits )
@lshift32-3 ( x** n^ -> x<<n )
    #18 SUB #40 SFT ( stash [n-24]<<4 )
    SFT NIP2 NIP #0000 #00 JMP2r

( x < y )
@lt32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 JMP2r } GTH2 #00 EQU JMP2r

( x > y )
@gteq32 ( x** y** -> bool^ )
    ROT2 SWP2 LTH2 ?{ LTH2 #00 EQU JMP2r } GTH2 JMP2r

( x / y )
@div32 ( x** y** -> q** )
    z_divmod32 ;z_divmod32/quo0 LDA2 ;z_divmod32/quo1 LDA2 JMP2r

( ( x % y ) )
( @mod32 ( x** y** -> r** ) )
(     z_divmod32 ;z_divmod32/rem0 LDA2 ;z_divmod32/rem1 LDA2 JMP2r )

( ( x / y, x % y ) )
( @divmod32 ( x** y** -> q** r** ) )
(     z_divmod32 )
(     ;z_divmod32/quo0 LDA2 ;z_divmod32/quo1 LDA2 )
(     ;z_divmod32/rem0 LDA2 ;z_divmod32/rem1 LDA2 )
(     JMP2r )

( private: calculate and store x / y and x % y )
@z_divmod32 ( x** y** -> )
    ( ; store y and x for repeated use )
    #0000 DUP2 ,&quo0 STR2 ,&quo1 STR2      ( x** y**         ; quo<-0 )
    STH2k ,&div1 STR2 STH2k ,&div0 STR2     ( x** [ylo* yhi*] ; div<-y )
    OVR2 OVR2 ,&rem1 STR2 ,&rem0 STR2       ( x** [ylo* yhi*] ; rem<-x )
    OVR2 OVR2 STH2r STH2r                   ( x** x** y** )
    OVR2 OVR2 STH2 STH2                     ( x** x** y** [ylo* yhi*] )
    gteq32 ?{ POP2 POP2 POP2r POP2r JMP2r } ( x** [ylo* yhi*] ; return if x < y )

    ( ; bitcount[x] - bitcount[y] determines largest multiple of y to try )
    bitcount32 STH2r STH2r bitcount32 SUB ( shift=rbits-dits^ )
    #00 DUP2                              ( shift^ 0^ shift^ 0^ )
    #0000 INC2k ROT2 POP                  ( shift^ 0^ 0* 1* shift^ )
    lshift32 ,&cur1 STR2 ,&cur0 STR2      ( shift^ 0^ ; cur<-1<<shift )
    ,&div0 LDR2 ,&div1 LDR2 ROT2 POP      ( div** shift^ )
    lshift32 ,&div1 STR2 ,&div0 STR2      ( ; div<-div<<shift )

    &loop
      ( ; if rem >= cur [current divisor], we can subtract it and add to quotient )
      ( ; otherwise, skip that iteration and reduce cur. )
      LIT2 [ &rem0 $2 ] LIT2 [ &rem1 $2 ] ,&div0 LDR2 ,&div1 LDR2
      lt32 ?{
        ( ; since rem >= div, we have found a multiple of y that divides x )
        ,&rem0 LDR2 ,&rem1 LDR2             ( rem** )
        LIT2 [ &div0 $2 ] LIT2 [ &div1 $2 ] ( rem** div** )
        sub32 ,&rem1 STR2 ,&rem0 STR2       ( ; rem<-rem-div** )
        LIT2 [ &quo0 $2 ] LIT2 [ &quo1 $2 ] ( quo** )
        LIT2 [ &cur0 $2 ] LIT2 [ &cur1 $2 ] ( quo** cur** )
        add32 ,&quo1 STR2 ,&quo0 STR2       ( ; quo<-quo+cur** )
      }
      ,&div0 LDR2 ,&div1 LDR2 #01 rshift32 ( div>>1** )
      ,&div1 STR2 ,&div0 STR2              ( ; div<-div>>1 )
      ,&cur0 LDR2 ,&cur1 LDR2 #01 rshift32 ( cur>>1** )
      OVR2 OVR2 ,&cur1 STR2 ,&cur0 STR2    ( cur>>1** ; cur<-cur>>1 )
      non-zero32 ?&loop JMP2r              ( ; loop if cur>0, else we're done )


@part [ 
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00   
	&b-beg 00 &b-end 00   
	( radix-sorted lists of color values )
	&count $4
	&r-sort $40 &g-sort $40 &b-sort $40
]

@part1 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $40 &g-sort $40 &b-sort $40
]

@part2 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $40 &g-sort $40 &b-sort $40
]

@part3 [
	( partition boundaries: start inclusive, end exclusive )
	&r-beg 00 &r-end 00
	&g-beg 00 &g-end 00
	&b-beg 00 &b-end 00
	( radix-sorted lists of color values )
	&count $4
	&r-sort $40 &g-sort $40 &b-sort $40
]

@filename "image.ff $0800
@file-buf-pre $20
@file-buf [ $3fe0 &pre-end $20 &end ]


( 3 line buffers, for dithering )
( 0x1800 = 6144 bytes; 6144 / 3 * 2 = 4096 pixels per line max )
( 0x1800 * 3 = 0x4800 )
@line-buffer [
	$2 &1 $1800 $2
	$2 &2 $1800 $2
	$2 &3 $1800 $2
]
@end
